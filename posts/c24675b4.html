<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>MySQL | 忆语</title><meta name="author" content="忆语"><meta name="copyright" content="忆语"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MYSQL 基础SQL 分类SQL 语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。     分类 全称 说明     DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段)   DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改   DQL Data Query La"><meta property="og:type" content="article"><meta property="og:title" content="MySQL"><meta property="og:url" content="https://blog.dyfnb.xyz/posts/c24675b4.html"><meta property="og:site_name" content="忆语"><meta property="og:description" content="MYSQL 基础SQL 分类SQL 语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。     分类 全称 说明     DDL Data Definition Language 数据定义语言，用来定义数据库对象(数据库，表，字段)   DML Data Manipulation Language 数据操作语言，用来对数据库表中的数据进行增删改   DQL Data Query La"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blogcdn.dyfnb.xyz/img/post/202306141153062.png"><meta property="article:published_time" content="2023-05-13T07:41:48.000Z"><meta property="article:modified_time" content="2023-06-14T05:49:10.526Z"><meta property="article:author" content="忆语"><meta property="article:tag" content="mysql"><meta property="article:tag" content="索引"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blogcdn.dyfnb.xyz/img/post/202306141153062.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.dyfnb.xyz/posts/c24675b4"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MySQL",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-06-14 13:49:10"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="baidu-site-verification" content="code-27ufQc9E7B"><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248 626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/clock.min.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="忆语" type="application/atom+xml"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blogcdn.dyfnb.xyz/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-fill"></use></svg> <span>追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw fas fa-heart faa-tada"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://blogcdn.dyfnb.xyz/img/post/202306141153062.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">忆语</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw fas fa-tags faa-tada"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw fas fa-folder-open faa-tada"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-fill"></use></svg> <span>追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw fas fa-heart faa-tada"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-13T07:41:48.000Z" title="发表于 2023-05-13 15:41:48">2023-05-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-14T05:49:10.526Z" title="更新于 2023-06-14 13:49:10">2023-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">33k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>113分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MySQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MYSQL-基础"><a href="#MYSQL-基础" class="headerlink" title="MYSQL 基础"></a>MYSQL 基础</h1><h2 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h2><p>SQL 语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">全称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">DDL</td><td style="text-align:center"><strong>Data Definition Language</strong></td><td style="text-align:center">数据定义语言，用来定义数据库对象(数据库，表，字段)</td></tr><tr><td style="text-align:center">DML</td><td style="text-align:center"><strong>Data Manipulation Language</strong></td><td style="text-align:center">数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td style="text-align:center">DQL</td><td style="text-align:center"><strong>Data Query Language</strong></td><td style="text-align:center">数据查询语言，用来查询数据库中表的记录</td></tr><tr><td style="text-align:center">DCL</td><td style="text-align:center"><strong>Data Control Language</strong></td><td style="text-align:center">数据控制语言，用来创建数据库用户、控制数据库的访问权限</td></tr></tbody></table></div><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ol><li>查询所有数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases ;</span><br></pre></td></tr></table></figure><ol><li>查询当前数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> database() ;</span><br></pre></td></tr></table></figure><ol><li>创建数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database [ if <span class="keyword">not</span> <span class="keyword">exists</span> ] 数据库名 [ <span class="keyword">default</span> charset 字符集 ] [ <span class="keyword">collate</span> 排序 规则 ] ;</span><br></pre></td></tr></table></figure><p>案例：</p><p>创建一个 itcast 数据库, 使用数据库默认的字符集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database itcast;</span><br></pre></td></tr></table></figure><p>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。可以通过 if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不创建。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> extists itcast;</span><br></pre></td></tr></table></figure><p>创建一个 itheima 数据库，并且指定字符集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database itheima <span class="keyword">default</span> charset utf8mb4;</span><br></pre></td></tr></table></figure><ol><li>删除数据库</li></ol><p>如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database [ if <span class="keyword">exists</span> ] 数据库名 ;</span><br></pre></td></tr></table></figure><ol><li>切换数据库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名 ;</span><br></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="查询-amp-创建"><a href="#查询-amp-创建" class="headerlink" title="查询&amp;创建"></a>查询&amp;创建</h4><ol><li>查询当前数据库所有表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><ol><li>查看指定表结构</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名 ;</span><br></pre></td></tr></table></figure><ol><li>查询指定表的建表语句</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名 ;</span><br></pre></td></tr></table></figure><p>通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询到，因为这部分是数据库的默认值，如：存储引擎、字符集等。</p><ol><li>创建表结构</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">  字段<span class="number">1</span> 字段<span class="number">1</span>类型 [ COMMENT 字段<span class="number">1</span>注释 ],</span><br><span class="line">  字段<span class="number">2</span> 字段<span class="number">2</span>类型 [COMMENT 字段<span class="number">2</span>注释 ],</span><br><span class="line">  字段<span class="number">3</span> 字段<span class="number">3</span>类型 [COMMENT 字段<span class="number">3</span>注释 ],</span><br><span class="line">  ......</span><br><span class="line">  字段n 字段n类型 [COMMENT 字段n注释 ]</span><br><span class="line">) [ COMMENT 表注释 ] ;</span><br></pre></td></tr></table></figure><blockquote><p>注意: [……] 内为可选参数，最后一个字段后面没有逗号</p></blockquote><p>创建一张表 tb_user ，对应的结构如下，那么建表语句为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tb_user(</span><br><span class="line">  id <span class="type">int</span> comment <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">50</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  age <span class="type">int</span> comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  gender <span class="type">varchar</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>MySQL 中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><ol><li>数值类型</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">有符号(SIGNED)范围</th><th style="text-align:center">无符号(UNSIGNED)范围</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">TINYINT</td><td style="text-align:center">1byte</td><td style="text-align:center">(-128，127)</td><td style="text-align:center">(0，255)</td><td style="text-align:center">小整数值</td></tr><tr><td style="text-align:center">SMALLINT</td><td style="text-align:center">2bytes</td><td style="text-align:center">(-32768，32767)</td><td style="text-align:center">(0，65535)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">MEDIUMINT</td><td style="text-align:center">3bytes</td><td style="text-align:center">(-8388608，8388607)</td><td style="text-align:center">(0，16777215)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">INT/INTEGER</td><td style="text-align:center">4bytes</td><td style="text-align:center">(-2147483648， 2147483647)</td><td style="text-align:center">(0，4294967295)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center">BIGINT</td><td style="text-align:center">8bytes</td><td style="text-align:center">(-2^63，2^63-1)</td><td style="text-align:center">(0，2^64-1)</td><td style="text-align:center">极大整数值</td></tr><tr><td style="text-align:center">FLOAT</td><td style="text-align:center">4bytes</td><td style="text-align:center">(-3.402823466 E+38， 3.402823466351 E+38)</td><td style="text-align:center">0 和 (1.175494351 E- 38，3.402823466 E+38)</td><td style="text-align:center">单精度浮点数</td></tr><tr><td style="text-align:center">DOUBLE</td><td style="text-align:center">8bytes</td><td style="text-align:center">(-1.7976931348623157 E+308， 1.7976931348623157 E+308)</td><td style="text-align:center">0 和 (2.2250738585072014 E-308， 1.7976931348623157 E+308)</td><td style="text-align:center">双精度浮点数值</td></tr><tr><td style="text-align:center">DECIMAL</td><td style="text-align:center"></td><td style="text-align:center">依赖于 M(精度)和 D(标度)的值</td><td style="text-align:center">依赖于 M(精度)和 D(标度)的值</td><td style="text-align:center">小数值(精确定点数)</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如:</span><br><span class="line"><span class="number">1</span>). 年龄字段 <span class="comment">-- 不会出现负数, 而且人的年龄不会太大</span></span><br><span class="line">age tinyint unsigned</span><br><span class="line"><span class="number">2</span>). 分数 <span class="comment">-- 总分100分, 最多出现一位小数</span></span><br><span class="line">score <span class="keyword">double</span>(<span class="number">4</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol><li>字符串类型</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CHAR</td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">定长字符串(需要指定长度)</td></tr><tr><td style="text-align:center">VARCHAR</td><td style="text-align:center">0-65535 bytes</td><td style="text-align:center">变长字符串(需要指定长度)</td></tr><tr><td style="text-align:center">TINYBLOB</td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">不超过 255 个字符的二进制数据</td></tr><tr><td style="text-align:center">TINYTEXT</td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">短文本字符串</td></tr><tr><td style="text-align:center">BLOB</td><td style="text-align:center">0-65 535 bytes</td><td style="text-align:center">二进制形式的长文本数据</td></tr><tr><td style="text-align:center">TEXT</td><td style="text-align:center">0-65 535 bytes</td><td style="text-align:center">长文本数据</td></tr><tr><td style="text-align:center">MEDIUMBLOB</td><td style="text-align:center">0-16 777 215 bytes</td><td style="text-align:center">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:center">MEDIUMTEXT</td><td style="text-align:center">0-16 777 215 bytes</td><td style="text-align:center">中等长度文本数据</td></tr><tr><td style="text-align:center">LONGBLOB</td><td style="text-align:center">0-4 294 967 295 bytes</td><td style="text-align:center">二进制形式的极大文本数据</td></tr><tr><td style="text-align:center">LONGTEXT</td><td style="text-align:center">0-4 294 967 295 bytes</td><td style="text-align:center">极大文本数据</td></tr></tbody></table></div><p>char 与 varchar 都可以描述字符串，char 是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而 varchar 是变长字符串，指定的长度为最大占用长度 。相对来说，char 的性能会更高些。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line"><span class="number">1</span>). 用户名 username <span class="comment">------&gt; 长度不定, 最长不会超过50</span></span><br><span class="line">username <span class="type">varchar</span>(<span class="number">50</span>)</span><br><span class="line"><span class="number">2</span>). 性别 gender <span class="comment">---------&gt; 存储值, 不是男,就是女</span></span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line"><span class="number">3</span>). 手机号 phone <span class="comment">--------&gt; 固定长度为11</span></span><br><span class="line">phone <span class="type">char</span>(<span class="number">11</span>)</span><br></pre></td></tr></table></figure><ol><li>日期时间类型</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">范围</th><th style="text-align:center">格式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">DATE</td><td style="text-align:center">3</td><td style="text-align:center">1000-01-01 至 9999-12-31</td><td style="text-align:center">YYYY-MM-DD</td><td style="text-align:center">日期值</td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">3</td><td style="text-align:center">-838:59:59 至 838:59:59</td><td style="text-align:center">HH:MM:SS</td><td style="text-align:center">时间值或持续时间</td></tr><tr><td style="text-align:center">YEAR</td><td style="text-align:center">1</td><td style="text-align:center">1901 至 2155</td><td style="text-align:center">YYYY</td><td style="text-align:center">年份值</td></tr><tr><td style="text-align:center">DATETIME</td><td style="text-align:center">8</td><td style="text-align:center">1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td style="text-align:center">YYYY-MM-DD HH:MM:SS</td><td style="text-align:center">混合日期和时间值</td></tr><tr><td style="text-align:center">TIMESTAMP</td><td style="text-align:center">4</td><td style="text-align:center">1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td style="text-align:center">YYYY-MM-DD HH:MM:SS</td><td style="text-align:center">混合日期和时间值，时间戳</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如:</span><br><span class="line"><span class="number">1</span>). 生日字段</span><br><span class="line">birthday birthday <span class="type">date</span></span><br><span class="line"><span class="number">2</span>). 创建时间</span><br><span class="line">createtime createtime datetime</span><br></pre></td></tr></table></figure><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><ol><li>添加字段</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">ADD</span> nickname <span class="type">varchar</span>(<span class="number">20</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>修改数据类型</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型 (长度);</span><br></pre></td></tr></table></figure><ol><li>修改字段名和字段类型</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将emp表的nickname字段修改为username，类型为varchar(30)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp CHANGE nickname username <span class="type">varchar</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>删除字段</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将emp表的字段username删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">DROP</span> username;</span><br></pre></td></tr></table></figure><ol><li>修改表名</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将emp表的表名修改为 employee</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp RENAME <span class="keyword">TO</span> employee;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ol><li>删除表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [ IF <span class="keyword">EXISTS</span> ] 表名;</span><br></pre></td></tr></table></figure><p>可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。</p><ol><li>删除指定表, 并重新创建表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 在删除表的时候，表中的全部数据也都会被删除。</p></blockquote><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><ol><li>给指定字段添加数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (字段名<span class="number">1</span>, 字段名<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">--  给employee表所有的字段添加数据 ；</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee(id,workno,name,gender,age,idcard,entrydate) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;Itcast&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;123456789012345678&#x27;</span>,<span class="string">&#x27;2000-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure><ol><li>给全部字段添加数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据到employee表，具体的SQL如下：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;张无忌&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;123456789012345670&#x27;</span>,<span class="string">&#x27;2005-01- 01&#x27;</span>);</span><br></pre></td></tr></table></figure><ol><li>批量添加数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (字段名<span class="number">1</span>, 字段名<span class="number">2</span>, ...) <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值 <span class="number">1</span>, 值<span class="number">2</span>, ...) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...), (值<span class="number">1</span>, 值<span class="number">2</span>, ...) ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入数据到employee表，具体的SQL如下：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;韦一笑&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">38</span>,<span class="string">&#x27;123456789012345670&#x27;</span>,<span class="string">&#x27;2005-01- 01&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;赵敏&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;123456789012345670&#x27;</span>,<span class="string">&#x27;2005-01-01&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期型数据应该包含在引号中。</li><li>插入的数据大小，应该在字段的规定范围内。</li></ul></blockquote><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>修改数据的具体语法为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span> , 字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span> , .... [ <span class="keyword">WHERE</span> 条件 ] ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--  修改id为1的数据, 将name修改为小昭, gender修改为 女</span></span><br><span class="line"><span class="keyword">update</span> employee <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;小昭&#x27;</span> , gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将所有的员工入职日期修改为 2008-01-01</span></span><br><span class="line"><span class="keyword">update</span> employee <span class="keyword">set</span> entrydate <span class="operator">=</span> <span class="string">&#x27;2008-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项: 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p></blockquote><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据的具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [ <span class="keyword">WHERE</span> 条件 ] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  删除gender为女的员工</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除所有员工</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> employee;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><ul><li><p>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。</p></li><li><p>DELETE 语句不能删除某一个字段的值(可以使用 UPDATE，将该字段值置为 NULL 即可)。</p></li><li><p>当进行删除全部数据操作时，datagrip 会提示我们，询问是否确认删除，我们直接点击 Execute 即可。</p></li></ul></blockquote><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>DQL 查询语句，语法结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名列表 <span class="keyword">WHERE</span> 条件列表 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段列表 <span class="keyword">HAVING</span> 分组后条件列表 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序字段列表 LIMIT 分页参数</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><p>查询多个字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>, 字段<span class="number">2</span>, 字段<span class="number">3</span> ... <span class="keyword">FROM</span> 表名 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 ;</span><br></pre></td></tr></table></figure><blockquote><p>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</p></blockquote><p>字段设置别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [ <span class="keyword">AS</span> 别名<span class="number">1</span> ] , 字段<span class="number">2</span> [ <span class="keyword">AS</span> 别名<span class="number">2</span> ] ... <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [ 别名<span class="number">1</span> ] , 字段<span class="number">2</span> [ 别名<span class="number">2</span> ] ... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p>去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表 ;</span><br></pre></td></tr></table></figure><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p>常用的比较运算符如下</p><div class="table-container"><table><thead><tr><th style="text-align:center">比较运算符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">></td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">>=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;&gt; 或 !=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">BETWEEN … AND …</td><td style="text-align:center">在某个范围之内(含最小、最大值)</td></tr><tr><td style="text-align:center">IN(…)</td><td style="text-align:center">在 in 之后的列表中的值，多选一</td></tr><tr><td style="text-align:center">LIKE 占位符</td><td style="text-align:center">模糊匹配(_匹配单个字符, %匹配任意个字符)</td></tr><tr><td style="text-align:center">IS NULL</td><td style="text-align:center">是 NULL</td></tr></tbody></table></div><p>常用的逻辑运算符如下:</p><div class="table-container"><table><thead><tr><th style="text-align:center">逻辑运算符</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">AND 或 &amp;&amp;</td><td style="text-align:center">并且 (多个条件同时成立)</td></tr><tr><td style="text-align:center">OR 或 \</td><td style="text-align:center">\</td><td></td><td>或者 (多个条件任意一个成立)</td></tr><tr><td style="text-align:center">NOT 或 !</td><td style="text-align:center">非 , 不是</td></tr></tbody></table></div><p>案例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询姓名为两个字的员工信息 _ %</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;__&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询身份证号最后一位是X的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">like</span> <span class="string">&#x27;%X&#x27;</span>; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">like</span> <span class="string">&#x27;_________________X&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>将一列数据作为一个整体，进行纵向计算 。常见的聚合函数有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">count</td><td style="text-align:center">统计数量</td></tr><tr><td style="text-align:center">max</td><td style="text-align:center">最大值</td></tr><tr><td style="text-align:center">min</td><td style="text-align:center">最小值</td></tr><tr><td style="text-align:center">avg</td><td style="text-align:center">平均值</td></tr><tr><td style="text-align:center">sum</td><td style="text-align:center">求和</td></tr></tbody></table></div><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表) <span class="keyword">FROM</span> 表名 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp; <span class="comment">-- 统计的是总记录数</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(idcard) <span class="keyword">from</span> emp; <span class="comment">-- 统计的是idcard字段不为null的记录数 12</span></span><br></pre></td></tr></table></figure><blockquote><p>注意 : NULL 值是不参与所有聚合函数运算的。</p></blockquote><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [ <span class="keyword">WHERE</span> 条件 ] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字段名 [ <span class="keyword">HAVING</span> 分组 后过滤条件 ];</span><br></pre></td></tr></table></figure><p>where 与 having 区别</p><ul><li><p>执行时机不同：where 是分组之前进行过滤，不满足 where 条件，不参与分组；而 having 是分组</p></li><li><p>之后对结果进行过滤。</p></li><li><p>判断条件不同：where 不能对聚合函数进行判断，而 having 可以。</p></li></ul><blockquote><p>注意事项:</p><ul><li><p>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。</p></li><li><p>执行顺序: where &gt; 聚合函数 &gt; having 。</p></li><li><p>支持多字段分组, 具体语法为 : group by columnA,columnB</p></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  根据性别分组 , 统计男性员工 和 女性员工的数量</span></span><br><span class="line"><span class="keyword">select</span> gender, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据性别分组 , 统计男性员工 和 女性员工的平均年龄</span></span><br><span class="line"><span class="keyword">select</span> gender, <span class="built_in">avg</span>(age) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</span></span><br><span class="line"><span class="keyword">select</span> workaddress, <span class="built_in">count</span>(<span class="operator">*</span>) address_count <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress <span class="keyword">having</span> address_count <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计各个工作地址上班的男性及女性员工的数量</span></span><br><span class="line"><span class="keyword">select</span> workaddress, gender, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="string">&#x27;数量&#x27;</span> <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> gender , workaddress ;</span><br></pre></td></tr></table></figure><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span> , 字段<span class="number">2</span> 排序方式<span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , entrydate <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><strong>排序方式</strong></p><ul><li>ASC : 升序(默认值)</li><li>DESC: 降序</li></ul><blockquote><p>注意事项：</p><ul><li><p>如果是升序, 可以不指定排序方式 ASC ;</p></li><li><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</p></li></ul></blockquote><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引, 查询记录数 ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询第1页员工数据, 每页展示10条记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">0</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询第2页员工数据, 每页展示10条记录 --------&gt; (页码-1)*页展示记录数</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">10</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><ul><li><p>起始索引从 0 开始，起始索引 = （查询页码 - 1）* 每页显示记录数。</p></li><li><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL 中是 LIMIT。</p></li><li><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p></li></ul></blockquote><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ol><li>查询用户</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306121813889.png" alt="">其中 Host 代表当前用户访问的主机, 如果为 localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 User 代表的是访问该数据库的用户名。在 MySQL 中需要通过 Host 和 User 来唯一标识一个用户。</p><p>创建用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>修改用户密码</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span> ;</span><br></pre></td></tr></table></figure><ol><li>删除用户</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> ;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><ul><li><p>在 MySQL 中需要通过用户名@主机名的方式，来唯一标识一个用户。</p></li><li><p>主机名可以使用 % 通配。</p></li><li><p>这类 SQL 开发人员操作的比较少，主要是 DBA（ Database Administrator 数据库管理员）使用。</p></li></ul></blockquote><h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p>MySQL 中定义了很多种权限，但是常用的就以下几种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ALL, ALL PRIVILEGES</td><td style="text-align:center">所有权限</td></tr><tr><td style="text-align:center">SELECT</td><td style="text-align:center">查询数据</td></tr><tr><td style="text-align:center">INSERT</td><td style="text-align:center">插入数据</td></tr><tr><td style="text-align:center">UPDATE</td><td style="text-align:center">修改数据</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">删除数据</td></tr><tr><td style="text-align:center">ALTER</td><td style="text-align:center">修改表</td></tr><tr><td style="text-align:center">DROP</td><td style="text-align:center">删除数据库/表/视图</td></tr><tr><td style="text-align:center">CREATE</td><td style="text-align:center">创建数据库/表</td></tr></tbody></table></div><p>其他权限描述及含义，可以直接参考<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html">官方文档</a>。</p><ol><li>查询权限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> ;</span><br></pre></td></tr></table></figure><ol><li>授予权限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>撤销权限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ul><li><p>多个权限之间，使用逗号分隔</p></li><li><p>授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p></li></ul></blockquote><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 &#x27;heima&#x27;@&#x27;%&#x27; 用户的权限</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;heima&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予 &#x27;heima&#x27;@&#x27;%&#x27; 用户itcast数据库所有表的所有操作权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> itcast.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;heima&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--  撤销 &#x27;heima&#x27;@&#x27;%&#x27; 用户的itcast数据库的所有权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> itcast.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;heima&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><p>MySQL 中内置了很多字符串函数，常用的几个如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CONCAT(S1,S2,…Sn)</td><td style="text-align:center">字符串拼接，将 S1，S2，… Sn 拼接成一个字符串</td></tr><tr><td style="text-align:center">LOWER(str)</td><td style="text-align:center">将字符串 str 全部转为小写</td></tr><tr><td style="text-align:center">UPPER(str)</td><td style="text-align:center">将字符串 str 全部转为大写</td></tr><tr><td style="text-align:center">LPAD(str,n,pad)</td><td style="text-align:center">左填充，用字符串 pad 对 str 的左边进行填充，达到 n 个字符串长度</td></tr><tr><td style="text-align:center">RPAD(str,n,pad)</td><td style="text-align:center">右填充，用字符串 pad 对 str 的右边进行填充，达到 n 个字符串长度</td></tr><tr><td style="text-align:center">TRIM(str)</td><td style="text-align:center">去掉字符串头部和尾部的空格</td></tr><tr><td style="text-align:center">SUBSTRING(str,start,len)</td><td style="text-align:center">返回从字符串 str 从 start 位置起的 len 个长度的字符串</td></tr></tbody></table></div><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><p>常见的数值函数如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CEIL(x)</td><td style="text-align:center">向上取整</td></tr><tr><td style="text-align:center">FLOOR(x)</td><td style="text-align:center">向下取整</td></tr><tr><td style="text-align:center">MOD(x,y)</td><td style="text-align:center">返回 x/y 的模</td></tr><tr><td style="text-align:center">RAND()</td><td style="text-align:center">返回 0~1 内的随机数</td></tr><tr><td style="text-align:center">ROUND(x,y)</td><td style="text-align:center">求参数 x 的四舍五入的值，保留 y 位小数</td></tr></tbody></table></div><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">CURDATE()</td><td style="text-align:center">返回当前日期</td></tr><tr><td style="text-align:center">CURTIME()</td><td style="text-align:center">返回当前时间</td></tr><tr><td style="text-align:center">NOW()</td><td style="text-align:center">返回当前日期和时间</td></tr><tr><td style="text-align:center">YEAR(date)</td><td style="text-align:center">获取指定 date 的年份</td></tr><tr><td style="text-align:center">MONTH(date)</td><td style="text-align:center">获取指定 date 的月份</td></tr><tr><td style="text-align:center">DAY(date)</td><td style="text-align:center">获取指定 date 的日期</td></tr><tr><td style="text-align:center">DATE_ADD(date, INTERVAL exprtype)</td><td style="text-align:center">返回一个日期/时间值加上一个时间间隔 expr 后的时间值</td></tr><tr><td style="text-align:center">DATEDIFF(date1,date2)</td><td style="text-align:center">返回起始时间 date1 和 结束时间 date2 之间的天数</td></tr></tbody></table></div><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><p>流程函数也是很常用的一类函数，可以在 SQL 语句中实现条件筛选，从而提高语句的效率。</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">IF(value , t , f)</td><td style="text-align:center">如果 value 为 true，则返回 t，否则返回 f</td></tr><tr><td style="text-align:center">IFNULL(value1 , value2)</td><td style="text-align:center">如果 value1 不为空，返回 value1，否则返回 value2</td></tr><tr><td style="text-align:center">CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td style="text-align:center">如果 val1 为 true，返回 res1，… 否则返回 default 默认值</td></tr><tr><td style="text-align:center">CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td style="text-align:center">如果 expr 的值等于 val1，返回 res1，… 否则返回 default 默认值</td></tr></tbody></table></div><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><div class="table-container"><table><thead><tr><th style="text-align:center">约束</th><th style="text-align:center">描述</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">非空约束</td><td style="text-align:center">限制该字段的数据不能为 null</td><td style="text-align:center">NOT NULL</td></tr><tr><td style="text-align:center">唯一约束</td><td style="text-align:center">保证该字段的所有数据都是唯一、不重复的</td><td style="text-align:center">UNIQUE</td></tr><tr><td style="text-align:center">主键约束</td><td style="text-align:center">主键是一行数据的唯一标识，要求非空且唯一</td><td style="text-align:center">PRIMARY KEY</td></tr><tr><td style="text-align:center">默认约束</td><td style="text-align:center">保存数据时，如果未指定该字段的值，则采用默认值</td><td style="text-align:center">DEFAULT</td></tr><tr><td style="text-align:center">检查约束(8.0.16 版本之后)</td><td style="text-align:center">保证字段值满足某一个条件</td><td style="text-align:center">CHECK</td></tr><tr><td style="text-align:center">外键约束</td><td style="text-align:center">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td style="text-align:center">FOREIGN KEY</td></tr></tbody></table></div><blockquote><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p></blockquote><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_user(</span><br><span class="line">  id <span class="type">int</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY COMMENT <span class="string">&#x27;ID唯一标识&#x27;</span>,</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;姓名&#x27;</span> ,</span><br><span class="line">  age <span class="type">int</span> <span class="keyword">check</span> (age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">120</span>) COMMENT <span class="string">&#x27;年龄&#x27;</span> ,</span><br><span class="line">  status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">  gender <span class="type">char</span>(<span class="number">1</span>) COMMENT <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306130953706.png" alt=""></p><p>左侧的 emp 表是员工表，里面存储员工的基本信息，包含员工的 ID、姓名、年龄、职位、薪资、入职日期、上级主管 ID、部门 ID，在员工的信息中存储的是部门的 ID dept_id，而这个部门的 ID 是关联的部门表 dept 的主键 id，那 emp 表的 dept_id 就是外键,关联的是另一张表的主键。</p><blockquote><p>注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联，所以是无法保证数据的一致性和完整性的。</p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>添加外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">  字段名 数据类型,</span><br><span class="line">  ...</span><br><span class="line">  [<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为emp表的dept_id字段添加外键约束,关联dept表的主键id</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id);</span><br></pre></td></tr></table></figure><p>删除外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除emp表的外键fk_emp_dept_id</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">foreign</span> key fk_emp_dept_id;</span><br></pre></td></tr></table></figure><h3 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h3><p>添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行为有以下几种:</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>行为</strong></th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">NO ACTION</td><td style="text-align:center">当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td style="text-align:center">RESTRICT</td><td style="text-align:center">当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td style="text-align:center">CASCADE</td><td style="text-align:center">当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录</td></tr><tr><td style="text-align:center">SET NULL</td><td style="text-align:center">当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为 null（这就要求该外键允许取 null）。</td></tr><tr><td style="text-align:center">SET DEFAULT</td><td style="text-align:center">父表有变更时，子表将外键列设置成一个默认的值 (Innodb 不支持)</td></tr></tbody></table></div><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CASCADE</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--  SET NULL</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id) <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">set</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span> ;</span><br></pre></td></tr></table></figure><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><ul><li><p>案例: 部门 与 员工的关系</p></li><li><p>关系: 一个部门对应多个员工，一个员工对应一个部门</p></li><li><p>实现: 在多的一方建立外键，指向一的一方的主键</p></li></ul><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><ul><li><p>案例: 学生 与 课程的关系</p></li><li><p>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择</p></li><li><p>实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p></li></ul><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><ul><li><p>案例: 用户 与 用户详情的关系</p></li><li><p>关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率</p></li><li><p>实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p></li></ul><h2 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>连接查询</p><ul><li>内连接：相当于查询 A、B 交集部分数据</li><li>外连接：<ul><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ul></li><li>自连接：当前表与自身的连接查询，自连接必须使用表别名</li></ul></li><li><p>子查询</p></li></ul><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306131022132.png" alt=""></p><p>内连接的语法分为两种: 隐式内连接、显式内连接。</p><p>隐式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> , 表<span class="number">2</span> <span class="keyword">WHERE</span> 条件 ... ;</span><br></pre></td></tr></table></figure><p>显式内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [ <span class="keyword">INNER</span> ] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件 ... ;</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)</span></span><br><span class="line"><span class="comment">表结构: emp , dept</span></span><br><span class="line"><span class="comment">连接条件: emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> emp.name , dept.name <span class="keyword">from</span> emp , dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id ;</span><br><span class="line"><span class="comment">-- 为每一张表起别名,简化SQL编写</span></span><br><span class="line"><span class="keyword">select</span> e.name,d.name <span class="keyword">from</span> emp e , dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) --- INNER JOIN ... ON ...</span></span><br><span class="line"><span class="comment">表结构: emp , dept</span></span><br><span class="line"><span class="comment">连接条件: emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> emp e <span class="keyword">inner</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"><span class="comment">-- 为每一张表起别名,简化SQL编写</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><blockquote><p>表的别名:</p><p>①. tablea as 别名 1 , tableb as 别名 2 ;</p><p>②. tablea 别名 1 , tableb 别名 2 ;</p><p>注意：一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。</p></blockquote><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306131029692.png" style="zoom:50%"></p><p>外连接分为两种，分别是：左外连接 和 右外连接。</p><p>左外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> [ <span class="keyword">OUTER</span> ] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ... ;</span><br></pre></td></tr></table></figure><p>左外连接相当于查询表 1(左表)的所有数据，当然也包含表 1 和表 2 交集部分的数据。</p><p>右外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> [ <span class="keyword">OUTER</span> ] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件 ... ;</span><br></pre></td></tr></table></figure><p>右外连接相当于查询表 2(右表)的所有数据，当然也包含表 1 和表 2 交集部分的数据。</p><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询emp表的所有数据, 和对应的部门信息</span></span><br><span class="line"><span class="comment">由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。</span></span><br><span class="line"><span class="comment">表结构: emp, dept</span></span><br><span class="line"><span class="comment">连接条件: emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.name <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.name <span class="keyword">from</span> emp e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询dept表的所有数据, 和对应的员工信息(右外连接)</span></span><br><span class="line"><span class="comment">由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。</span></span><br><span class="line"><span class="comment">表结构: emp, dept</span></span><br><span class="line"><span class="comment">连接条件: emp.dept_id = dept.id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>, e.<span class="operator">*</span> <span class="keyword">from</span> emp e <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>, e.<span class="operator">*</span> <span class="keyword">from</span> dept d <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id</span><br></pre></td></tr></table></figure><blockquote><p>注意事项：</p><p>左外连接和右外连接是可以相互替换的，只需要调整在连接查询时 SQL 中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p></blockquote><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><h3 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h3><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A 别名A <span class="keyword">JOIN</span> 表A 别名B <span class="keyword">ON</span> 条件 ... ;</span><br></pre></td></tr></table></figure><p>而对于自连接查询，可以是内连接查询，也可以是外连接查询。</p><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询员工 及其 所属领导的名字</span></span><br><span class="line"><span class="comment">表结构: emp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> a.name , b.name <span class="keyword">from</span> emp a , emp b <span class="keyword">where</span> a.managerid <span class="operator">=</span> b.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来</span></span><br><span class="line"><span class="comment">表结构: emp a , emp b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> a.name <span class="string">&#x27;员工&#x27;</span>, b.name <span class="string">&#x27;领导&#x27;</span> <span class="keyword">from</span> emp a <span class="keyword">left</span> <span class="keyword">join</span> emp b <span class="keyword">on</span> a.managerid <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><blockquote><p>注意事项:</p><p>在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。</p></blockquote><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>对于 union 查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [ <span class="keyword">ALL</span> ]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ....;</span><br></pre></td></tr></table></figure><ul><li><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</p></li><li><p>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</p></li></ul><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来.</span></span><br><span class="line"><span class="comment">当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们也可以通过union/union all来联合查询.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span>;</span><br><span class="line"><span class="comment">-- union all查询出来的结果，仅仅进行简单的合并，并未去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- union 联合查询，会对查询出来的结果进行去重处理。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>如果多条查询语句查询出来的结果，字段数量不一致，在进行 union/union all 联合查询时，将会报错。</p></blockquote><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>SQL 语句中嵌套 SELECT 语句，称为嵌套查询，又称子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> column1 <span class="operator">=</span> ( <span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> t2 );</span><br></pre></td></tr></table></figure><p>子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个。</p><p><strong>分类</strong></p><p>根据子查询结果不同，分为：</p><ul><li><p>标量子查询（子查询结果为单个值）</p></li><li><p>列子查询(子查询结果为一列)</p></li><li><p>行子查询(子查询结果为一行)</p></li><li><p>表子查询(子查询结果为多行多列)</p></li></ul><p>根据子查询位置，分为：</p><ul><li><p>WHERE 之后</p></li><li><p>FROM 之后</p></li><li><p>SELECT 之后</p></li></ul><h3 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h3><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。</p><p>常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;=</p><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询 &quot;销售部&quot; 的所有员工信息</span></span><br><span class="line"><span class="comment">完成这个需求时，我们可以将需求分解为两步：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- ①. 查询 &quot;销售部&quot; 部门ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="comment">-- ②. 根据 &quot;销售部&quot; 部门ID, 查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h3><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">IN</td><td style="text-align:center">在指定的集合范围之内，多选一</td></tr><tr><td style="text-align:center">NOT IN</td><td style="text-align:center">不在指定的集合范围之内</td></tr><tr><td style="text-align:center">ANY</td><td style="text-align:center">子查询返回列表中，有任意一个满足即可</td></tr><tr><td style="text-align:center">SOME</td><td style="text-align:center">与 ANY 等同，使用 SOME 的地方都可以使用 ANY</td></tr><tr><td style="text-align:center">ALL</td><td style="text-align:center">子查询返回列表的所有值都必须满足</td></tr></tbody></table></div><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询 &quot;销售部&quot; 和 &quot;市场部&quot; 的所有员工信息</span></span><br><span class="line"><span class="comment">分解为以下两步:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- ①. 查询 &quot;销售部&quot; 和 &quot;市场部&quot; 的部门ID</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据部门ID, 查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询比 财务部 所有人工资都高的员工信息</span></span><br><span class="line"><span class="comment">分解为以下两步:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="comment">-- ①. 查询所有 财务部 人员工资</span></span><br><span class="line"> <span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>;</span><br><span class="line"> <span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">-- ②. 比 财务部 所有人工资都高的员工信息</span></span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span> ( <span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询比研发部其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="comment">分解为以下两步:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- ①. 查询研发部所有人工资</span></span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ②. 比研发部其中任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">any</span> ( <span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>) );</span><br></pre></td></tr></table></figure><h3 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h3><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p>常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询与 &quot;张无忌&quot; 的薪资及直属领导相同的员工信息 ;</span></span><br><span class="line"><span class="comment">这个需求同样可以拆解为两步进行:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- ①. 查询 &quot;张无忌&quot; 的薪资及直属领导</span></span><br><span class="line"><span class="keyword">select</span> salary, managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ②. 查询与 &quot;张无忌&quot; 的薪资及直属领导相同的员工信息 ;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary, managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为表子查询。</p><p>常用的操作符：IN</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询与 &quot;鹿杖客&quot; , &quot;宋远桥&quot; 的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="comment">分解为两步执行:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- ①. 查询 &quot;鹿杖客&quot; , &quot;宋远桥&quot; 的职位和薪资</span></span><br><span class="line"><span class="keyword">select</span> job, salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;鹿杖客&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;宋远桥&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询与 &quot;鹿杖客&quot; , &quot;宋远桥&quot; 的职位和薪资相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (job,salary) <span class="keyword">in</span> ( <span class="keyword">select</span> job, salary <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;鹿杖客&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;宋远桥&#x27;</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询入职日期是 &quot;2006-01-01&quot; 之后的员工信息 , 及其部门信息</span></span><br><span class="line"><span class="comment">分解为两步执行:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">-- ①. 入职日期是 &quot;2006-01-01&quot; 之后的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ②. 查询这部分员工, 对应的部门信息;</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id ;</span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>索引是数据库表中的字段的索引，所谓的索引就是在表的字段上添加的，每个字段都可以添加索引来提高查找效率，也可以多个字段联合添加一个索引。</p><p>参考字典的实现，索引相当于字典的目录，通过目录缩小查找范围。</p><ul><li>优点<ul><li>提高数据检索效率，降低数据库的 IO 成本</li><li>通过索引对数据进行排序，降低排序成本，降低 CPU 消耗</li></ul></li><li>缺点<ul><li>索引需要占用空间</li><li>索引提高了查询效率，同时也降低了 INSERT、UPDATE、DELETE(更新)的效率</li><li>索引需要维护</li></ul></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">存储结构</th><th style="text-align:center">描述</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td style="text-align:center">B+Tree</td><td style="text-align:center">最常见的索引，大部分存储引擎都支持 B+树索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td style="text-align:center">Hash 索引</td><td style="text-align:center">底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才能有效，不支持范围查询</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td style="text-align:center">R-Tree(空间索引)</td><td style="text-align:center">空间索引是 MyISAM 引擎的一个特殊索引，主要用于地理空间数据类型，通常使用较少</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td style="text-align:center">Full-text(全文索引)</td><td style="text-align:center">是一种通过建立倒排索引，快速匹配文档的方式，类似 Lucene，ES</td><td>5.6 以后支持</td><td>支持</td><td>不支持</td></tr></tbody></table></div><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>MySQL 的索引结构采用二叉树的数据结构，比较理想的结构如下：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221451480.png" alt="二叉树理想情况" style="zoom:50%"></p><p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221454397.png" alt="主键插入" style="zoom:50%"></p><p>如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li>顺序插入时，会形成一个链表，查询性能大大降低。</li><li>大数据量情况下，层级较深，检索速度慢。</li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一颗自平衡二叉树，那这样即使是顺序插入数 据，最终形成的数据结构也是一颗平衡的二叉树,结构如下:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221456706.png" alt="红黑树结构" style="zoom:50%"></p><p>即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点： 大数据量情况下，层级较深，检索速度慢。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B-Tree，B 树是一种多路平衡查找树，相对于二叉树，B 树每个节点可以有多个分支，即多叉。 以一颗最大度数（max-degree）为 5(5 阶)的 b-tree 为例，那这个 B 树每个节点最多存储 4 个 key，5 个指针：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221459357.png" alt="B树结构"></p><p>特点：</p><ul><li>5 阶的 B 树，每一个节点最多存储 4 个 key，对应 5 个指针。</li><li>一旦节点存储的 key 数量到达 5，就会裂变，中间元素向上分裂。</li><li>在 B 树中，非叶子节点和叶子节点都会存放数据。</li></ul><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree 是 B-Tree 的变种，我们以一颗最大度数（max-degree）为 4（4 阶）的 b+tree 为例，来看一 下其结构示意图：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221517866.png" alt="B+树结构"></p><p>B+Tree 结构特点：</p><ul><li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li><li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</li></ul><p>B+Tree 与 B-Tree 相比，主要有以下三点区别：</p><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个单向链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能，利于排序。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221526057.png" alt="B+树索引"></p><h3 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h3><p>哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221531437.png" alt=""></p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了 hash 冲突（也称为 hash 碰撞），可 以通过链表来解决。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221533880.png" alt="hash碰撞"></p><p>特点</p><ul><li>Hash 索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常(不存在 hash 冲突的情况)只需要一次检索就可以了，效率通常要高于 B+tree 索引</li></ul><p>存储引擎支持</p><ul><li>在 MySQL 中，支持 hash 索引的是 Memory 存储引擎。 而 InnoDB 中具有自适应 hash 功能，hash 索引是 InnoDB 存储引擎根据 B+Tree 索引在指定条件下自动构建的。</li></ul><blockquote><p>思考题： 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构?</p><ul><li>相对于二叉树，层级更少，搜索效率高；</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</li><li>相对 Hash 索引，B+Tree 支持范围匹配及排序操作；</li></ul></blockquote><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>在 MySQL 数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">含义</th><th style="text-align:center">特点</th><th style="text-align:center">关键字</th></tr></thead><tbody><tr><td style="text-align:center">主键索引</td><td style="text-align:center">针对于表中主键创建的索引</td><td style="text-align:center">默认自动创建, 只能有一个</td><td style="text-align:center">PRIMARY</td></tr><tr><td style="text-align:center">唯一索引</td><td style="text-align:center">避免同一个表中某数据列中的值重复</td><td style="text-align:center">可以有多个</td><td style="text-align:center">UNIQUE</td></tr><tr><td style="text-align:center">常规索引</td><td style="text-align:center">快速定位特定数据</td><td style="text-align:center">可以有多个</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">全文索引</td><td style="text-align:center">全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td style="text-align:center">可以有多个</td><td style="text-align:center">FULLTEXT</td></tr></tbody></table></div><h3 id="聚集索引-amp-二级索引"><a href="#聚集索引-amp-二级索引" class="headerlink" title="聚集索引&amp;二级索引"></a>聚集索引&amp;二级索引</h3><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">含义</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">聚集索引(Clustered Index)</td><td style="text-align:center">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td style="text-align:center">必须有,而且只 有一个</td></tr><tr><td style="text-align:center">二级索引(Secondary Index)</td><td style="text-align:center">将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td><td style="text-align:center">可以存在多个</td></tr></tbody></table></div><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索 引。</li></ul><p>聚集索引和二级索引的具体结构如下：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221712510.png" alt="聚集索引和二级索引的具体结构"></p><ul><li><p>聚集索引的叶子节点下挂的是这一行的数据 。</p></li><li><p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p></li></ul><p>当我们执行如下的 SQL 语句时，具体的查找过程：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221715597.png" alt="查询过程"></p><p>具体过程如下:</p><ol><li>由于是根据 name 字段进行查询，所以先根据 name=’Arm’到 name 字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是*，所以此时，还需要根据主键值 10，到聚集索引中查找 10 对应的记录，最 终找到 10 对应的行 row。</li><li>最终拿到这一行的数据，直接返回即可。</li></ol><blockquote><p><strong>回表查询</strong>： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</p><p>思考题： InnoDB 主键索引的 B+tree 高度为多高呢?</p><p>假设: 一行数据大小为 1k，一页中可以存储 16 行这样的数据。</p><p>InnoDB 的指针占用 6 个字节的空 间，主键即使为 bigint，占用字节数为 8。</p><p>高度为 2：</p><p>n <em>8 + (n + 1)</em> 6 = 16<em>1024 , 算出 n 约为 1170 1171</em> 16 = 18736 也就是说，如果树的高度为 2，则可以存储 18000 多条记录。</p><p>高度为 3：</p><p>1171 <em>1171</em> 16 = 21939856 也就是说，如果树的高度为 3，则可以存储 2200w 左右的记录。</p></blockquote><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ] INDEX index_name <span class="keyword">ON</span> table_name ( index_col_name,... )</span><br></pre></td></tr></table></figure><p>查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name ;</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name ;</span><br></pre></td></tr></table></figure><h2 id="SQL-性能分析"><a href="#SQL-性能分析" class="headerlink" title="SQL 性能分析"></a>SQL 性能分析</h2><h3 id="SQL-的执行频率"><a href="#SQL-的执行频率" class="headerlink" title="SQL 的执行频率"></a>SQL 的执行频率</h3><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session 是查看当前会话 ;</span></span><br><span class="line"><span class="comment">-- global 是查询全局数据 ;</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221753996.png" alt="状态信息"></p><ul><li>Com_delete: 删除次数</li><li>Com_insert: 插入次数</li><li>Com_select: 查询次数</li><li>Com_update: 更新次数</li></ul><blockquote><p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据 库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以 查询为主，那么就要考虑对数据库的索引进行优化了。</p></blockquote><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10 秒）的所有 SQL 语句的日志。 MySQL 的慢查询日志默认没有开启，我们可以查看一下系统变量 slow_query_log。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221759516.png" alt=""></p><p>如果要开启慢查询日志，需要在 MySQL 的配置文件（/etc/my.cnf）中配置如下信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启MySQL慢日志查询开关</span></span><br><span class="line"><span class="string">slow_query_log=1</span></span><br><span class="line"><span class="comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line"><span class="string">long_query_time=2</span></span><br></pre></td></tr></table></figure><p>配置完毕之后，通过以下指令重新启动 MySQL 服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221826125.png" alt="开启MySQL慢日志"></p><p><strong>测试</strong>：</p><p>执行如下 SQL 语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user; <span class="comment">-- 这条SQL执行效率比较高, 执行耗时 0.00sec</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_sku; <span class="comment">-- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时</span></span><br><span class="line"><span class="number">13.35</span>sec</span><br></pre></td></tr></table></figure><p>检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的 SQL，执行较快的 SQL 是不会记录的。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305221828964.png" alt=" 检查慢查询日志 "></p><p>通过慢查询日志，就可以定位出执行效率比较低的 SQL，从而有针对性的进行优化。</p><h3 id="profile-详情"><a href="#profile-详情" class="headerlink" title="profile 详情"></a>profile 详情</h3><p>show profiles 能够在做 SQL 优化时帮助我们了解时间都耗费到哪里去了。通过 have_profiling 参数，能够看到当前 MySQL 是否支持 profile 操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have</span>_profiling ;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231124810.png" alt=""></p><p>可以通过 profiling 参数查看当前 MySQL 的 profile 开关是否开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@profiling</span> ;#<span class="number">0</span>：关闭；<span class="number">1</span>:开启</span><br></pre></td></tr></table></figure><p>若开关是关闭的。可以通过 set 语句在 session/global 级别开启 profiling：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>接下来，我们所执行的 SQL 语句，都会被 MySQL 记录，并记录执行时间消耗到哪儿去 了。 我们直接执行如下的 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;白起&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_sku;</span><br></pre></td></tr></table></figure><p>执行一系列的业务 SQL 的操作，然后通过如下指令查看指令的执行耗时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看每一条SQL的耗时基本情况</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"><span class="comment">-- 查看指定query_id的SQL语句CPU的使用情况</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><p>查看每一条 SQL 的耗时情况:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231131679.png" alt=""></p><p>查看指定 SQL 各个阶段的耗时情况 :</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231133093.png" alt=""></p><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。</p><p>语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接在select语句之前加上关键字 explain / desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 ;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231134929.png" alt="EXPLAIN执行结果"></p><p>Explain 执行计划中各个字段的含义:</p><div class="table-container"><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">select 查询的序列号，表示查询中执行 select 子句或者是操作表的顺序 (id 相同，执行顺序从上到下；id 不同，值越大，越先执行)。</td></tr><tr><td style="text-align:center">select_type</td><td style="text-align:center">表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE 之后包含了子查询）等</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">表示连接类型，性能由好到差的连接类型为 NULL（不访问任何表）、system（访问系统表）、const（根据主键或唯一索引进行访问）、 eq_ref、ref（使用非唯一性的索引进行访问）、range、 index（使用了索引但会对索引进行扫描遍历整个索引树）、all（全表扫描）。</td></tr><tr><td style="text-align:center">possible_key</td><td style="text-align:center">显示可能应用在这张表上的索引，一个或多个。</td></tr><tr><td style="text-align:center">key</td><td style="text-align:center">实际使用的索引，如果为 NULL，则没有使用索引。</td></tr><tr><td style="text-align:center">key_len</td><td style="text-align:center">表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td></tr><tr><td style="text-align:center">rows</td><td style="text-align:center">MySQL 认为必须要执行查询的行数，在 innodb 引擎的表中，是一个估计值， 可能并不总是准确的。</td></tr><tr><td style="text-align:center">filtered</td><td style="text-align:center">表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td></tr></tbody></table></div><h2 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h2><h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，<strong>索引将会部分失效(后面的字段索引失效)</strong>。</p><p>以 tb_user 表为例，先查看一下之前 tb_user 表所创建的索引</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231411800.png" alt="tb_user 表所创建的索引"></p><p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status。 对于最左前缀法则指的是，查询时，最左边的列，也就是 profession 必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。 接下来，我们来演示几组案例，看一下 具体的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status</span><br><span class="line"><span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231412325.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231414528.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231415828.png" alt=""></p><p>以上的这三组测试中，我们发现只要联合索引最左边的字段 profession 存在，索引就会生效，只不 过索引的长度不同。 而且由以上三组测试，我们也可以推测出 profession 字段索引长度为 47、age 字段索引长度为 2、status 字段索引长度为 5。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231417419.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231418405.png" alt=""></p><p>而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引最左边的列 profession 不存在。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231419952.png" alt=""></p><p>上述的 SQL 查询时，存在 profession 字段，最左边的列是存在的，索引满足最左前缀法则的基本条 件。但是查询时，跳过了 age 这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索 引的长度就是 47。</p><blockquote><p>思考题：</p><p>当执行 SQL 语句: explain select * from tb_user where age = 31 and status = ‘0’ and profession = ‘软件工程’； 时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231421926.png" alt=""></p><p>可以看到，是完全满足最左前缀法则的，索引长度 54，联合索引是生效的。 注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写 SQL 时，条件编写的先后顺序无关。</p></blockquote><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231427562.png" alt=""></p><p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为 49，就说明范围查询右边的 status 字 段是没有走索引的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;=</span> <span class="number">30</span> <span class="keyword">and</span></span><br><span class="line">status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</p><h3 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h3><h4 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h4><p>不要在索引列上进行运算操作，<strong>否则会导致索引失效</strong></p><p>当根据 phone 字段进行等值匹配查询时, 索引生效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231433463.png" alt=""></p><p>当根据 phone 字段进行函数运算操作之后，索引失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231434946.png" alt=""></p><h4 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h4><p>字符串类型字段使用时，不加引号，索引将失效。</p><p>通过两组示例，来看看对于字符串类型的字段，加单引号与不加单引号的区别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231435161.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">17799990015</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231436287.png" alt=""></p><p>如果字符串不加单引号，对于查询结果，没什么影响，但是数 据库存在隐式类型转换，索引将失效。</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>通过这三条 SQL 语句的执行效果，查看一下其执行计划： 由于下面查询语句中，都是根据 profession 字段查询，符合最左前缀法则，联合索引是可以生效的， 我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231439613.png" alt=""></p><p>经过上述的测试，在 like 模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。</p><h4 id="or-连接条件"><a href="#or-连接条件" class="headerlink" title="or 连接条件"></a>or 连接条件</h4><p>用 or 分割开的条件， 如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990017&#x27;</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231440989.png" alt=""></p><p>由于 age 没有索引，所以即使 id、phone 有索引，索引也会失效。所以需要针对于 age 也要建立索引。 然后，我们可以对 age 字段建立索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_age <span class="keyword">on</span> tb_user(age);</span><br></pre></td></tr></table></figure><p>建立了索引之后，我们再次执行上述的 SQL 语句，看看前后执行计划的变化。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231442643.png" alt=""></p><p>最终，我们发现，当 or 连接的条件，左右两侧字段都有索引时，索引才会生效。</p><h4 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h4><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990005&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231443995.png" alt=""></p><p>经过测试我们发现，相同的 SQL 语句，只是传入的字段值不同，最终的执行计划也完全不一样</p><p>因为 MySQL 在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p><p>接下来，我们再来看看 is null 与 is not null 操作是否走索引。 执行如下两条语句 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231445909.png" alt=""></p><p>接下来，我们将 profession 字段值全部更新为 null。</p><p>然后，再次执行上述的两条 SQL，查看 SQL 语句的执行计划。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231446909.png" alt=""></p><p>一模一样的 SQL 语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种现象，这是和数据库的数据分布有关系。查询时 MySQL 会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null 是否走索引，得具体情况具体分析，并不是固定的</p><h3 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h3><p>目前 tb_user 表的数据情况如下:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231459137.png" alt=""></p><p>索引情况如下:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231512968.png" alt=""></p><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_user_age <span class="keyword">on</span> tb_user;</span><br><span class="line"><span class="keyword">drop</span> index idx_email <span class="keyword">on</span> tb_user;</span><br></pre></td></tr></table></figure><p>执行 SQL : explain select * from tb_user where profession = ‘软件工程’;</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231530442.png" alt=""></p><p>查询走了联合索引。</p><p>执行 SQL，创建 profession 的单列索引：create index idx_user_pro on tb_user(profession);</p><p>创建单列索引后，再次执行刚才的 SQL 语句，查看执行计划</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231532360.png" alt=""></p><p>测试结果，我们可以看到，possible_keys 中 idx_user_pro_age_sta,idx_user_pro 这两个索引都可能用到，最终 MySQL 选择了 idx_user_pro_age_sta 索引。这是 MySQL 自动选择的结果。</p><p>那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于 MySQL 的 SQL 提示来完成。 接下来，介绍一下 SQL 提示。</p><p>SQL 提示，是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优 化操作的目的。</p><ol><li>use index ： 建议 MySQL 使用哪一个索引完成此次查询（仅仅是建议，mysql 内部还会再次进 行评估）。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>ignore index ： 忽略指定的索引</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>force index ： 强制使用索引。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure><p>演示：</p><ul><li>use index</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231548618.png" alt=""></p><ul><li>ignore index</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from tb_user ignore index(idx_user_pro) where profession = &#x27;软件工程&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231550118.png" alt=""></p><ul><li>force index</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro_age_sta) <span class="keyword">where</span> profession <span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231551246.png" alt=""></p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>尽量使用覆盖索引，减少 select *。 那么什么是覆盖索引呢？ 覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id, profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line">explain <span class="keyword">select</span> id,profession,age, status <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line">explain <span class="keyword">select</span> id,profession,age, status, name <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> ;</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述这几条 SQL 的执行结果为:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231554803.png" alt=""></p><p>从上述的执行计划我们可以看到，这四条 SQL 语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的 Extra，前面两条 SQL 的结果为 Using where; Using Index ; 而后面两条 SQL 的结果为: Using index condition 。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Extra</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Using where; Using Index</td><td style="text-align:center">查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td></tr><tr><td style="text-align:center">Using index condition</td><td style="text-align:center">查找使用了索引，但是需要回表查询数据</td></tr></tbody></table></div><p>因为，在 tb_user 表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段 profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主 键 id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引 直接返回数据了。 如果超出这个范围，就需要拿到主键 id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用 select * 查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p><p>SQL 的执行过程：</p><p>表结构及索引示意图:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231611482.png" alt=""></p><p>id 是主键，是一个聚集索引。 name 字段建立了普通索引，是一个二级索引（辅助索引）。</p><p>执行 SQL : select * from tb_user where id = 2;</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231629428.png" alt=""></p><p>根据 id 查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><p>执行 SQL：selet id,name from tb_user where name = ‘Arm’;</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231630588.png" alt=""></p><p>虽然是根据 name 字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在 name 的二级索 引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p><p>执行 SQL：selet id,name,gender from tb_user where name = ‘Arm’;</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231633224.png" alt=""></p><p>由于在 name 的二级索引中，不包含 gender，所以，需要两次索引扫描，也就是需要回表查询，性能相对较差一点。</p><blockquote><p>思考题：</p><p>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对 以下 SQL 语句进行优化, 该如何进行才是最优方案:</p><p>select id,username,password from tb_user where username = ‘itcast’;</p><p>答案: 针对于 username, password 建立联合索引, sql 为: create index idx_user_name_pass on tb_user(username,password); 这样可以避免上述的 SQL 语句，在查询的过程中，出现回表查询。</p></blockquote><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>当字段类型为字符串（varchar，text，longtext 等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘 IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p><strong>语法</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n));</span><br></pre></td></tr></table></figure><p>示例:</p><p>为 tb_user 表的 email 字段，建立长度为 5 的前缀索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_email_5 <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231638884.png" alt=""></p><p><strong>前缀长度</strong></p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br></pre></td></tr></table></figure><p><strong>前缀索引的查询流程</strong></p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231648462.png" alt=""></p><h3 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h3><p><strong>单列索引</strong>：即一个索引只包含单个列。</p><p><strong>联合索引</strong>：即一个索引包含了多个列。</p><p>tb_user 表中目前的索引情况:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231650961.png" alt=""></p><p>在查询出来的索引中，既有单列索引，又有联合索引。</p><p>执行一条 SQL 语句，看看其执行计划：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231651809.png" alt=""></p><p>通过上述执行计划我们可以看出来，在 and 连接的两个字段 phone、name 上都是有单列索引的，但是 最终 mysql 只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。</p><p>紧接着，我们再来创建一个 phone 和 name 字段的联合索引来查询一下执行计划。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone_name <span class="keyword">on</span> tb_user(phone,name);</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231652457.png" alt=""></p><p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name 的信息，在叶子节点下挂的是对应的主键 id，所以查询是无需回表查询的。</p><blockquote><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p></blockquote><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305231654154.png" alt=""></p><h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><ol><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。</li><li>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol><h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br></pre></td></tr></table></figure><ol><li><p>优化方案一</p><p>批量插入数据</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure><ol><li><p>优化方案二</p><p>手动控制事务</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><ol><li><p>优化方案三</p><p>主键顺序插入，性能要高于乱序插入。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主键乱序插入 : <span class="number">8</span> <span class="number">1</span> <span class="number">9</span> <span class="number">21</span> <span class="number">88</span> <span class="number">2</span> <span class="number">4</span> <span class="number">15</span> <span class="number">89</span> <span class="number">5</span> <span class="number">7</span> <span class="number">3</span></span><br><span class="line">主键顺序插入 : <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">21</span> <span class="number">88</span> <span class="number">89</span></span><br></pre></td></tr></table></figure><h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用 insert 语句插入性能较低，此时可以使 用 MySQL 数据库提供的 load 指令进行插入。操作如下：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241125426.png" alt=""></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 客户端连接服务端时，加上参数 -–local-infile</span></span><br><span class="line">mysql –<span class="operator">-</span><span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 执行load指令将准备好的数据，加载到表结构中</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields</span><br><span class="line">terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> ;</span><br></pre></td></tr></table></figure><blockquote><p>在 load 时，主键顺序插入性能高于乱序插入</p></blockquote><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。</p><h3 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h3><p>在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241129780.png" alt=""></p><p>行数据，都是存储在聚集索引的叶子节点上的。而我们之前也讲解过 InnoDB 的逻辑结构图：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241130624.png" alt=""></p><p>在 InnoDB 引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认 16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行 row 在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。</p><h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>页可以为空，也可以填充一半，也可以填充 100%。每个页包含了 2-N 行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><p><strong>主键顺序插入效果</strong></p><ol><li>从磁盘中申请页， 主键顺序插入</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241132343.png" alt=""></p><ol><li>第一个页没有满，继续往第一页插入</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241133693.png" alt=""></p><ol><li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241134544.png" alt=""></p><p><strong>主键乱序插入效果</strong></p><ol><li>假如 1#,2#页都已经写满了，存放了如图所示的数据</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241137730.png" alt=""></p><ol><li>此时再插入 id 为 50 的记录</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241138035.png" alt=""></p><p>会再次开启一个页，写入新的页中吗？不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在 47 之后。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241139995.png" alt=""></p><p>但是 47 所在的 1#页，已经写满了，存储不了 50 对应的数据了。 那么此时会开辟一个新的页 3#。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241140948.png" alt=""></p><p>但是并不会直接将 50 存入 3#页，而是会将 1#页后一半的数据，移动到 3#页，然后在 3#页，插入 50。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241140398.png" alt=""></p><p>移动数据，并插入 id 为 50 的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是 3#， 3#的下一个页是 2#。 所以，此时，需要重新设置链表指针。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241141793.png" alt=""></p><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>目前表中已有数据的索引结构(叶子节点)如下：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241143534.png" alt=""></p><p>当我们对已有数据进行删除时，具体的效果如下: 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241144420.png" alt=""></p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的 50%），InnoDB 会开始寻找最靠近的页（前 或后）看看是否可以将两个页合并以优化空间使用。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241145689.png" alt=""></p><p>删除数据，并将页合并之后，再次插入新的数据 21，则直接插入 3#页</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241145565.png" alt=""></p><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><blockquote><p>知识小贴士： MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p></blockquote><h3 id="索引设计原则-1"><a href="#索引设计原则-1" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键。</li><li>尽量不要使用 UUID 做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul><p><img src="https://blogcdn.dyfnb.xyz/img/post/202305241149980.png" alt=""></p><h2 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h2><p>MySQL 的排序，有两种方式：</p><p><strong>Using filesort</strong> : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p><strong>Using index</strong> : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index 的性能高，而 Using filesort 的性能低，我们在优化排序 操作时，尽量要优化为 Using index。</p><p><strong>执行排序 SQL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age ;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021445277.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age, phone ;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021502435.png" alt=""></p><p>由于 age, phone 都没有索引，所以此时再排序时，出现 Using filesort， 排序性能较低。</p><p><strong>创建索引</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_age_phone_aa <span class="keyword">on</span> tb_user(age,phone);</span><br></pre></td></tr></table></figure><p><strong>创建索引后，根据 age, phone 进行升序排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021504345.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age , phone;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021505866.png" alt=""></p><p>建立索引之后，再次进行排序查询，就由原来的 Using filesort， 变为了 Using index，性能就是比较高。</p><p><strong>创建索引后，根据 age, phone 进行降序排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> , phone <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021506959.png" alt=""></p><p>也出现 Using index， 但是此时 Extra 中出现了 Backward index scan，这个代表反向扫描索引，因为在 MySQL 中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在 MySQL8 版本中，支持降序索引，我们也可以创建降序索引。</p><p>根据 phone，age 进行升序排序，phone 在前，age 在后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> phone , age; <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021509865.png" alt=""></p><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age 是第一个字段，phone 是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><p>根据 age, phone 进行降序一个升序，一个降序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , phone <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021510224.png" alt=""></p><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时</p><p>就会出现 Using filesort。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021511107.png" alt=""></p><p>为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序，phone 倒序排序。</p><p>创建联合索引(age 升序排序，phone 倒序排序)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_age_phone_ad <span class="keyword">on</span> tb_user(age <span class="keyword">asc</span> ,phone <span class="keyword">desc</span>);</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021512410.png" alt=""></p><p>然后再次执行如下 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , phone <span class="keyword">desc</span> ; <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021513383.png" alt=""></p><p><strong>升序/降序联合索引结构图示</strong></p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021514295.png" alt=""></p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021514903.png" alt=""></p><p><strong>由上述的测试,我们得出 order by 优化原则:</strong></p><ol><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</li><li>如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认 256k)。</li></ol><blockquote><p><strong>注</strong>：我们编写 SQL 时，条件编写的先后顺序无关；但是排序时，索引字段就该按照这个顺序来，否则就会出现 Using filesort。</p></blockquote><h2 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h2><p>分组操作，我们主要来看看索引对于分组操作的影响。</p><p>执行如下 SQL，查询执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> profession , <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession ;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021536354.png" alt=""></p><p>然后，我们在针对于 profession ， age， status 创建一个联合索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession , age , status);</span><br></pre></td></tr></table></figure><p>再执行前面相同的 SQL 查看执行计划</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> profession , <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession ;</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021537923.png" alt=""></p><p>再执行如下的分组查询 SQL，查看执行计划：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021538464.png" alt=""></p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021539949.png" alt=""></p><p>们发现，如果仅仅根据 age 分组，就会出现 Using temporary ；而如果是根据 profession,age 两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作，在联合索引中，也是符合最左前缀法则的。</p><p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p><ol><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ol><h2 id="limit-优化"><a href="#limit-优化" class="headerlink" title="limit 优化"></a>limit 优化</h2><p>在数据量比较大时，如果进行 limit 分页查询，在查询时，越往后，分页查询效率越低。</p><p>执行 limit 分页查询耗时对比：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306021557502.png" alt=""></p><p>越往后，分页查询效率越低，这就是分页查询的问题所在。</p><p>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p><p><strong>优化思路</strong>: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查</p><p>询形式进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku t , (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id <span class="operator">=</span> a.id;</span><br></pre></td></tr></table></figure><h2 id="count-优化"><a href="#count-优化" class="headerlink" title="count 优化"></a>count 优化</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user ;</span><br></pre></td></tr></table></figure><p>如果数据量很大，在执行 count 操作时，是非常耗时的。</p><ul><li><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的 count，MyISAM 也慢。</p></li><li><p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数</p></li></ul><p>如果说要大幅度提升 InnoDB 表的 count 效率，主要的优化思路：自己计数(可以借助于 redis 这样的数据库进行,但是如果是带条件的 count 又比较麻烦了)。</p><h3 id="count-用法"><a href="#count-用法" class="headerlink" title="count 用法"></a>count 用法</h3><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>用法：count（*）、count（主键）、count（字段）、count（数字）</p><div class="table-container"><table><thead><tr><th style="text-align:center">count 用法</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">count(主键)</td><td style="text-align:center">InnoDB 引擎会遍历整张表，把每一行的 主键 id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为 null)</td></tr><tr><td style="text-align:center">count(字段)</td><td style="text-align:center">没有 not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为 null，不为 null，计数累加。有 not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr><tr><td style="text-align:center">count(数字 )</td><td style="text-align:center">InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</td></tr><tr><td style="text-align:center">count(*)</td><td style="text-align:center">InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</td></tr></tbody></table></div><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)，所以尽量使用 count(*)。</p><h2 id="update-优化"><a href="#update-优化" class="headerlink" title="update 优化"></a>update 优化</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;javaEE&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure><p>当我们在执行删除的 SQL 语句时，会锁定 id 为 1 这一行的数据，然后事务提交之后，行锁释放。</p><p>但是当我们在执行如下 SQL 时:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;SpringBoot&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;PHP&#x27;</span> ;</span><br></pre></td></tr></table></figure><p>当我们开启多个事务，在执行上述的 SQL 时，我们发现行锁升级为了表锁。 导致该 update 语句的性能大大降低。</p><blockquote><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</p></blockquote><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p><strong>视图（view）</strong>是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个 select 语句保存在数据字典中的。</p><p>视图只保存了查询的 SQL 逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条 SQL 查询语句上。</p><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><h3 id="新建视图"><a href="#新建视图" class="headerlink" title="新建视图"></a>新建视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ]</span><br></pre></td></tr></table></figure><h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看创建视图语句：</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br><span class="line"><span class="comment">-- 查看视图数据：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名称 ...... ;</span><br></pre></td></tr></table></figure><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式一：</span></span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ]</span><br><span class="line"><span class="comment">-- 方式二：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [ <span class="keyword">WITH</span> [ <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> ] <span class="keyword">CHECK</span> OPTION ]</span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称 [,视图名称] ...</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 查询视图</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 修改视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,<span class="keyword">no</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">10</span>; <span class="keyword">alter</span> <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> stu_v_1;</span><br></pre></td></tr></table></figure><p>通过视图来插入、更新数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_1 <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_1 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;Tom22&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行上述的 SQL，我们会发现，id 为 6 和 17 的数据都是可以成功插入的。 但是我们执行查询，查询出来的数据，却没有 id 为 17 的记录。</p><p>因为我们在创建视图的时候，指定的条件为 id&lt;=10, id 为 17 的数据，是不符合条件的，所以没有查询出来，但是这条数据确实是已经成功的插入到了基表中。</p><p>如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p><h2 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h2><p>当使用 WITH CHECK OPTION 子句创建视图时，MySQL 会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。 MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql 提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。</p><h3 id="CASCADED-级联"><a href="#CASCADED-级联" class="headerlink" title="CASCADED 级联"></a>CASCADED 级联</h3><p>比如，v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 cascaded，但是 v1 视图创建时未指定检查选项。 则在执行检查时，不仅会检查 v2，还会级联检查 v2 的关联视图 v1</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306031419176.png" alt=""></p><h3 id="LOCAL-本地"><a href="#LOCAL-本地" class="headerlink" title="LOCAL 本地"></a>LOCAL 本地</h3><p>比如，v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 local ，但是 v1 视图创建时未指定检查选项。 则在执行检查时，只会检查 v2，不会检查 v2 的关联视图 v1。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306031430742.png" alt=""></p><h2 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h2><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ol><li>聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者 UNION ALL</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_v_count <span class="keyword">as</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p>上述的视图中，就只有一个单行单列的数据，如果我们对这个视图进行更新或插入的，将会报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_count <span class="keyword">values</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306031519124.png" alt=""></p><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><ol><li><strong>简单</strong></li></ol><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p><ol><li><strong>安全</strong></li></ol><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p><ol><li><strong>数据独立</strong></li></ol><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p><strong>特点：</strong></p><ul><li>封装，复用 ———————————-&gt; 可以把某一业务 SQL 封装在存储过程中，需要用到的时候直接调用即可。</li><li>可以接收参数，也可以返回数据 ————&gt; 再存储过程中，可以传递参数，也可以接收返回值。</li><li>减少网络交互，效率提升 ——————-&gt; 如果涉及到多条 SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</li></ul><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 名称 ([ 参数 ]);</span><br></pre></td></tr></table></figure><h3 id="更新存储过程"><a href="#更新存储过程" class="headerlink" title="更新存储过程"></a>更新存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="keyword">WHERE</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>; <span class="comment">-- 查询指定数据库的存储过程及状态信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ; <span class="comment">-- 查询某个存储过程的定义</span></span><br></pre></td></tr></table></figure><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [ IF <span class="keyword">EXISTS</span> ] 存储过程名称 ；</span><br></pre></td></tr></table></figure><blockquote><p>注意:</p><p>在命令行中，执行创建存储过程的 SQL 时，需要通过关键字 delimiter 指定 SQL 语句的结束符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$; <span class="comment">-- 指定结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student; <span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储过程基本语法</span></span><br><span class="line"><span class="comment">-- 创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1() <span class="keyword">begin</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student; <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">call</span> p1();</span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA <span class="operator">=</span> <span class="string">&#x27;itcast&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p1;</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p1;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在 MySQL 中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><strong>系统变量</strong>是 MySQL 服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION），在用的时候直接用 “@@变量名” 使用就可以。</p><ol><li>查看系统变量</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES ; <span class="comment">-- 查看所有系统变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;......&#x27;</span>; <span class="comment">-- 可以通过LIKE模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">SELECT</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] 系统变量名; <span class="comment">-- 查看指定变量的值</span></span><br></pre></td></tr></table></figure><ol><li>设置系统变量</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] 系统变量名 <span class="operator">=</span> 值 ;</span><br><span class="line"><span class="keyword">SET</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>]系统变量名 <span class="operator">=</span> 值 ;</span><br></pre></td></tr></table></figure><blockquote><p>注意:</p><p>如果没有指定 SESSION/GLOBAL，默认是 SESSION，会话变量。</p><p>mysql 服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。</p><ul><li>全局变量(GLOBAL): 全局变量针对于所有的会话。</li><li>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</li></ul></blockquote><p><strong>示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看系统变量</span></span><br><span class="line"><span class="keyword">show</span> session variables ;</span><br><span class="line"><span class="keyword">show</span> session variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.autocommit;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span>.autocommit;</span><br><span class="line"><span class="comment">-- 设置系统变量</span></span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course(id, name) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">&#x27;ES&#x27;</span>);</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.autocommit;</span><br></pre></td></tr></table></figure><h3 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h3><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接。</p><ol><li>赋值</li></ol><p>方式一:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@var</span>_name <span class="operator">=</span> expr [, <span class="variable">@var</span>_name <span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@var</span>_name :<span class="operator">=</span> expr [, <span class="variable">@var</span>_name :<span class="operator">=</span> expr] ... ;</span><br></pre></td></tr></table></figure><p>赋值时，可以使用 = ，也可以使用 := 。</p><p>方式二:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var</span>_name :<span class="operator">=</span> expr [, <span class="variable">@var</span>_name :<span class="operator">=</span> expr] ... ;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> <span class="variable">@var</span>_name <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><ol><li>使用</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="variable">@var</span>_name ;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为 NULL。</p></blockquote><p><strong>示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 赋值</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myname</span> <span class="operator">=</span> <span class="string">&#x27;itcast&#x27;</span>; <span class="keyword">set</span> <span class="variable">@myage</span> :<span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@mygender</span> :<span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>,<span class="variable">@myhobby</span> :<span class="operator">=</span> <span class="string">&#x27;java&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@mycolor</span> :<span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@mycount</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@myname</span>,<span class="variable">@myage</span>,<span class="variable">@mygender</span>,<span class="variable">@myhobby</span>; <span class="keyword">select</span> <span class="variable">@mycolor</span> , <span class="variable">@mycount</span>;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要 DECLARE 声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的 BEGIN … END 块之间。</p><ol><li>声明</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 变量类型 [<span class="keyword">DEFAULT</span> ... ] ;</span><br></pre></td></tr></table></figure><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME 等。</p><ol><li>赋值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 值 ; <span class="keyword">SET</span> 变量名 :<span class="operator">=</span> 值 ; <span class="keyword">SELECT</span> 字段名 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名 ... ;</span><br></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明局部变量 - declare</span></span><br><span class="line"><span class="comment">-- 赋值</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p2()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> stu_count <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> stu_count <span class="keyword">from</span> student;</span><br><span class="line">	<span class="keyword">select</span> stu_count;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">call</span> p2();</span><br></pre></td></tr></table></figure><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if 用于做条件判断，具体的语法结构为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line">	.....</span><br><span class="line">ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span> <span class="comment">-- 可选</span></span><br><span class="line">	.....</span><br><span class="line"><span class="keyword">ELSE</span> <span class="comment">-- 可选</span></span><br><span class="line">	.....</span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure><p>在 if 条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE 结构可以有，也可以没有。</p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">IN</td><td style="text-align:center">该类参数作为输入，也就是需要调用时传入值</td><td style="text-align:center">默认</td></tr><tr><td style="text-align:center">OUT</td><td style="text-align:center">该类参数作为输出，也就是该参数可以作为返回值</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">INOUT</td><td style="text-align:center">既可以作为输入参数，也可以作为输出参数</td></tr></tbody></table></div><p><strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称 ([ <span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型 ])</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p>根据传入参数 score，判定当前分数对应的分数等级，并返回。</p><ul><li><p>score &gt;= 85 分，等级为优秀。</p></li><li><p>score &gt;= 60 分 且 score &lt; 85 分，等级为及格。</p></li><li><p>score &lt; 60 分，等级为不及格。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p4(<span class="keyword">in</span> score <span class="type">int</span>, <span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">	elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line">	<span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明</span></span><br><span class="line"><span class="keyword">call</span> p4(<span class="number">18</span>, <span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br></pre></td></tr></table></figure><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>case 结构及作用，和我们在基础篇中所讲解的流程控制函数很类似。有两种语法格式：</p><p>语法 1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时， 执行statement_list2， 否则就执行 statement_list</span></span><br><span class="line"><span class="keyword">CASE</span> case_value</span><br><span class="line">	<span class="keyword">WHEN</span> when_value1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">	[ <span class="keyword">WHEN</span> when_value2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">	[ <span class="keyword">ELSE</span> statement_list ]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>语法 2:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成 立时，执行statement_list2， 否则就执行 statement_list</span></span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">	<span class="keyword">WHEN</span> search_condition1 <span class="keyword">THEN</span> statement_list1</span><br><span class="line">  [<span class="keyword">WHEN</span> search_condition2 <span class="keyword">THEN</span> statement_list2] ...</span><br><span class="line">  [<span class="keyword">ELSE</span> statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p6(<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">case</span></span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第一季度&#x27;</span>;</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">6</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第二季度&#x27;</span>;</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">9</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第三季度&#x27;</span>;</span><br><span class="line">		<span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span> <span class="operator">&lt;=</span> <span class="number">12</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;第四季度&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;非法参数&#x27;</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">case</span> ;</span><br><span class="line">	<span class="keyword">select</span> concat(<span class="string">&#x27;您输入的月份为: &#x27;</span>,<span class="keyword">month</span>, <span class="string">&#x27;, 所属的季度为: &#x27;</span>,<span class="keyword">result</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p6(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p></blockquote><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的 SQL 语句。具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span></span><br><span class="line">WHILE 条件 DO</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值; -- B. 每循环一次, 就会对n进行减1 , 如果n减到0, 则退出循环</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p7(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line">		<span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">		<span class="keyword">set</span> n :<span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p7(<span class="number">100</span>); <span class="number">910111213</span></span><br></pre></td></tr></table></figure><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><p>repeat 是有条件的循环控制语句, 当满足 until 声明的条件的时候，则退出循环 。具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span></span><br><span class="line">REPEAT</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line">UNTIL 条件</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值; -- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p8(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	repeat</span><br><span class="line">		<span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">		<span class="keyword">set</span> n :<span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">	until n <span class="operator">&lt;=</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">end</span> repeat;</span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><p>LOOP 实现简单的循环，如果不在 SQL 逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP 可以配合一下两个语句使用：</p><ul><li>LEAVE ：配合循环使用，退出循环。</li><li>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">	<span class="keyword">SQL</span>逻辑...</span><br><span class="line"><span class="keyword">END</span> LOOP [end_label];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEAVE label; <span class="comment">-- 退出指定标记的循环体</span></span><br><span class="line">ITERATE label; <span class="comment">-- 直接进入下一次循环</span></span><br></pre></td></tr></table></figure><p>上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</p><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A. 定义局部变量, 记录累加之后的值;</span></span><br><span class="line"><span class="comment">-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	sum:loop</span><br><span class="line">		if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">			leave sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">		if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">			<span class="keyword">set</span> n :<span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">			iterate sum;</span><br><span class="line">		<span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">		<span class="keyword">set</span> n :<span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span> loop sum;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p9(<span class="number">100</span>); <span class="number">11121314151617181920</span></span><br></pre></td></tr></table></figure><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>声明游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句 ;</span><br></pre></td></tr></table></figure><p>打开游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名称 ;</span><br></pre></td></tr></table></figure><p>获取游标记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量 [, 变量 ] ;</span><br></pre></td></tr></table></figure><p>关闭游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名称 ;</span><br></pre></td></tr></table></figure><h2 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h2><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p><p>具体语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> handler_action HANDLER <span class="keyword">FOR</span> condition_value [, condition_value] ... statement ;</span><br><span class="line">handler_action 的取值：</span><br><span class="line">	CONTINUE: 继续执行当前程序</span><br><span class="line">	EXIT: 终止执行当前程序</span><br><span class="line">condition_value 的取值：</span><br><span class="line">	<span class="keyword">SQLSTATE</span> sqlstate_value: 状态码，如 <span class="number">02000</span></span><br><span class="line">	<span class="keyword">SQLWARNING</span>: 所有以<span class="number">01</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line">	<span class="keyword">NOT</span> FOUND: 所有以<span class="number">02</span>开头的<span class="keyword">SQLSTATE</span>代码的简写</span><br><span class="line">	<span class="keyword">SQLEXCEPTION</span>: 所有没有被<span class="keyword">SQLWARNING</span> 或 <span class="keyword">NOT</span> FOUND捕获的<span class="keyword">SQLSTATE</span>代码的简写</span><br></pre></td></tr></table></figure><p><strong>案例</strong></p><p>根据传入的参数 uage，来查询用户表 tb_user 中，所有的用户年龄小于等于 uage 的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>通过 SQLSTATE 指定具体的状态码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 逻辑:</span></span><br><span class="line"><span class="comment">-- A. 声明游标, 存储查询结果集</span></span><br><span class="line"><span class="comment">-- B. 准备: 创建表结构</span></span><br><span class="line"><span class="comment">-- C. 开启游标</span></span><br><span class="line"><span class="comment">-- D. 获取游标中的记录</span></span><br><span class="line"><span class="comment">-- E. 插入数据到新表中</span></span><br><span class="line"><span class="comment">-- F. 关闭游标</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出</span></span><br><span class="line">	<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">open</span> u_cursor;</span><br><span class="line">  while <span class="literal">true</span> do</span><br><span class="line">  	<span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">  	<span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>, uname, upro);</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line">  <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p11(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>通过 SQLSTATE 的代码简写方式 NOT FOUND</p><p>02 开头的状态码，代码简写为 NOT FOUND</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 逻辑:</span></span><br><span class="line"><span class="comment">-- A. 声明游标, 存储查询结果集</span></span><br><span class="line"><span class="comment">-- B. 准备: 创建表结构</span></span><br><span class="line"><span class="comment">-- C. 开启游标</span></span><br><span class="line"><span class="comment">-- D. 获取游标中的记录</span></span><br><span class="line"><span class="comment">-- E. 插入数据到新表中</span></span><br><span class="line"><span class="comment">-- F. 关闭游标</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出</span></span><br><span class="line">	<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">close</span> u_cursor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">open</span> u_cursor;</span><br><span class="line">  while <span class="literal">true</span> do</span><br><span class="line">  	<span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">  	<span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>, uname, upro);</span><br><span class="line">  <span class="keyword">end</span> while;</span><br><span class="line">  <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p11(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>具体的错误状态码，可以参考官方文档：</p><p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html">https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html</a></strong></p><p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html</a></strong></p><h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><p>存储函数是有返回值的存储过程，存储函数的参数只能是 IN 类型的。具体语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 存储函数名称 ([ 参数列表 ])</span><br><span class="line"><span class="keyword">RETURNS</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line">	<span class="keyword">RETURN</span> ...;</span><br><span class="line"><span class="keyword">END</span> ;</span><br></pre></td></tr></table></figure><p>characteristic 说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><p><strong>案例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fun1(n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line">		<span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">		<span class="keyword">set</span> n :<span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line">	<span class="keyword">return</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> fun1(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>在 mysql8.0 版本中 binlog 默认是开启的，一旦开启了，mysql 就要求在定义存储过程时，需要指定 characteristic 特性，否则就会报如下错误：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306041436408.png" alt=""></p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>触发器是与表有关的数据库对象，指在 insert/update/delete 之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的 SQL 语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。</p><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><div class="table-container"><table><thead><tr><th style="text-align:center">触发器类型</th><th style="text-align:center">NEW 和 OLD</th></tr></thead><tbody><tr><td style="text-align:center">INSERT 型触发器</td><td style="text-align:center">NEW 表示将要或者已经新增的数据</td></tr><tr><td style="text-align:center">UPDATE 型触发器</td><td style="text-align:center">OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td style="text-align:center">DELETE 型触发器</td><td style="text-align:center">OLD 表示将要或者已经删除的数据</td></tr></tbody></table></div><h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">	BEFORE<span class="operator">/</span>AFTER <span class="keyword">INSERT</span><span class="operator">/</span><span class="keyword">UPDATE</span><span class="operator">/</span><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">ON</span> tbl_name <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	trigger_stmt ; <span class="comment">-- 触发器具体逻辑</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS ;</span><br></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name ; <span class="comment">-- 如果没有指定 schema_name，默认为当前数 据库 。</span></span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表 user_logs 中, 包含增加,修改 , 删除 ;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">	after <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <span class="keyword">VALUES</span>(<span class="keyword">null</span>, <span class="string">&#x27;insert&#x27;</span>, now(), 		new.id, concat(<span class="string">&#x27;插入的数据内容为: id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name, <span class="string">&#x27;, phone=&#x27;</span>, NEW.phone, <span class="string">&#x27;, email=&#x27;</span>, NEW.email, 		<span class="string">&#x27;, profession=&#x27;</span>, NEW.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">	after <span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <span class="keyword">VALUES</span>(<span class="keyword">null</span>, <span class="string">&#x27;update&#x27;</span>, now(), 		new.id, concat(<span class="string">&#x27;更新之前的数据: id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,old.name, <span class="string">&#x27;, phone=&#x27;</span>, old.phone, <span class="string">&#x27;, email=&#x27;</span>, old.email, <span class="string">&#x27;, 		profession=&#x27;</span>, old.profession, <span class="string">&#x27; | 更新之后的数据: id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name, <span class="string">&#x27;, phone=&#x27;</span>, NEW.phone, <span class="string">&#x27;, 			email=&#x27;</span>, NEW.email, <span class="string">&#x27;, profession=&#x27;</span>, NEW.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_delete_trigger</span><br><span class="line">	after <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operate_time, operate_id, operate_params) <span class="keyword">VALUES</span>(<span class="keyword">null</span>, <span class="string">&#x27;delete&#x27;</span>, now(), 		old.id, concat(<span class="string">&#x27;删除之前的数据: id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,old.name, <span class="string">&#x27;, phone=&#x27;</span>, old.phone, <span class="string">&#x27;, email=&#x27;</span>, old.email, <span class="string">&#x27;, 		profession=&#x27;</span>, old.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL 中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的 DDL、DML 全部都处于阻塞状态，但是可以执行 DQL 语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><p>加全局锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock ;</span><br></pre></td></tr></table></figure><p>数据备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot –p1234 itcast <span class="operator">&gt;</span> itcast.sql</span><br></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables ;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ul><p>在 InnoDB 引擎中，我们可以在备份时加上参数 —single-transaction 参数来完成不加锁的一致性数据备份。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot –p123456 itcast &gt; itcast.sql</span></span><br></pre></td></tr></table></figure><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM、InnoDB、BDB 等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li><p>表锁</p></li><li><p>元数据锁（meta data lock，MDL）</p></li><li><p>意向锁</p></li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对于表锁，分为两类：</p><ul><li><p>表共享读锁（read lock）</p></li><li><p>表独占写锁（write lock）</p></li></ul><p><strong>语法：</strong></p><ul><li><p>加锁：lock tables 表名… read/write。</p></li><li><p>释放锁：unlock tables / 客户端断开连接 。</p></li></ul><p><strong>特点：</strong></p><p><strong>读锁</strong></p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306042038071.png" alt=""></p><p>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。</p><p><strong>写锁</strong></p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051349637.png" alt=""></p><p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p><blockquote><p>结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</p></blockquote><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>meta data lock , 元数据锁，简写 MDL。</p><p>MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免<strong>DML</strong>与<strong>DDL</strong>冲突，保证读写的正确性。</p><p>这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p><p>在 MySQL5.5 中引入了 MDL，当对一张表进行增删改查的时候，加 MDL 读锁(共享)；当对表结构进行变更操作的时候，加 MDL 写锁(排他)。</p><p>常见的 SQL 操作时，所添加的元数据锁：</p><div class="table-container"><table><thead><tr><th style="text-align:center">对应 SQL</th><th style="text-align:center">锁类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">lock tables xxx read /write</td><td style="text-align:center">SHARED_READ_ONLY /SHARED_NO_READ_WRITE</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">select 、select … lock in share mode</td><td style="text-align:center">SHARED_READ</td><td style="text-align:center">与 SHARED_READ、SHARED_WRITE 兼容，与 EXCLUSIVE 互斥</td></tr><tr><td style="text-align:center">insert 、update、delete、select … for</td><td style="text-align:center">SHARED_WRITE</td><td style="text-align:center">与 SHARED_READ、SHARED_WRITE 兼容，与 EXCLUSIVE 互斥</td></tr><tr><td style="text-align:center">alter table …</td><td style="text-align:center">EXCLUSIVE</td><td style="text-align:center">与其他的 MDL 都互斥</td></tr></tbody></table></div><p>查看元数据锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_type,object_schema,object_name,lock_type,lock_duration <span class="keyword">from</span> performance_schema.metadata_locks ;</span><br></pre></td></tr></table></figure><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p><p>首先客户端一，开启一个事务，然后执行 DML 操作，在执行 DML 语句时，会对涉及到的行加行锁。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051443858.png" alt=""></p><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051444732.png" alt=""></p><p>有了意向锁之后 :</p><p>客户端一，在执行 DML 操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051445906.png" alt=""></p><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051447509.png" alt=""></p><p><strong>分类</strong></p><ul><li><p>意向共享锁(IS): 由语句 select … lock in share mode 添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。</p></li><li><p>意向排他锁(IX): 由 insert、update、delete、select…for update 添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</p></li></ul><blockquote><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p></blockquote><p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC、RR 隔离级别下都支持。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051450322.png" alt=""></p></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051451009.png" alt=""></p></li><li><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。 在 RR 隔离级别下支持。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051452810.png" alt=""></p></li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB 实现了以下两种类型的行锁：</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p></li><li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p></li></ul><p>两种行锁的兼容情况如下:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051501128.png" alt=""></p><p>常见的 SQL 语句，在执行时，所加的行锁如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">SQL</th><th style="text-align:center">行锁类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">INSERT …</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">UPDATE …</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">DELETE …</td><td style="text-align:center">排他锁</td><td style="text-align:center">自动加锁</td></tr><tr><td style="text-align:center">SELECT（正常）</td><td style="text-align:center">不加任何锁</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SELECT … LOCK IN SHARE MODE</td><td style="text-align:center">共享锁</td><td style="text-align:center">需要手动在 SELECT 之后加 LOCK IN SHARE MODE</td></tr><tr><td style="text-align:center">SELECT … FOR UPDATE</td><td style="text-align:center">排他锁</td><td style="text-align:center">需要手动在 SELECT 之后加 FOR UPDATE</td></tr></tbody></table></div><p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时 就会升级为表锁。</p></li></ul><p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h3 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB 在 REPEATABLE READ 事务隔离级别运行，InnoDB 使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ul><li><p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</p></li><li><p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-keylock 退化为间隙锁。</p></li><li>索引上的范围查询(唯一索引)—会访问到不满足条件的第一个值为止。</li></ul><blockquote><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p></blockquote><h1 id="InnoDB-引擎"><a href="#InnoDB-引擎" class="headerlink" title="InnoDB 引擎"></a>InnoDB 引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p>InnoDB 的逻辑存储结构如下图所示:</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051611781.png" alt=""></p><ol><li>表空间</li></ol><p>表空间是 InnoDB 存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0 版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个 mysql 实例可以对应多个表空间，用于存储记录、索引等数据。</p><ol><li>段</li></ol><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB 是索引组织表，数据段就是 B+树的叶子节点， 索引段即为 B+树的非叶子节点。段用来管理多个 Extent（区）。</p><ol><li>区</li></ol><p>区，表空间的单元结构，每个区的大小为 1M。 默认情况下， InnoDB 存储引擎页大小为 16K， 即一个区中一共有 64 个连续的页。</p><ol><li>页</li></ol><p>页，是 InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><ol><li>行</li></ol><p>行，InnoDB 存储引擎数据是按行进行存放的。</p><p>在行中，默认有两个隐藏字段：</p><ul><li><p>Trx_id：每次对某条记录进行改动时，都会把对应的事务 id 赋值给 trx_id 隐藏列。</p></li><li><p>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>MySQL5.5 版本开始，默认使用 InnoDB 存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是 InnoDB 架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051624700.png" alt=""></p><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 接下来介绍一下这四个部分。</p><ol><li>Buffer Pool</li></ol><p>InnoDB 存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的 I/O 效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘 I/O。</p><p>在 InnoDB 的缓冲池中不仅缓存了索引页和数据页，还包含了 undo 页、插入缓存、自适应哈希索引以及 InnoDB 的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘 IO，加快处理速度。</p><p>缓冲池以 Page 页为单位，底层采用链表数据结构管理 Page。根据状态，将 Page 分为三种类型：</p><ul><li><p>free page：空闲 page，未被使用。</p></li><li><p>clean page：被使用 page，数据没有被修改过。</p></li><li><p>dirty page：脏页，被使用 page，数据被修改过，也中数据与磁盘的数据产生了不一致。</p></li></ul><p>在专用服务器上，通常将多达 80％的物理内存分配给缓冲池 。参数设置： show variables like ‘innodb_buffer_pool_size’;</p><ol><li>Change Buffer</li></ol><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行 DML 语句时，如果这些数据 Page 没有在 Buffer Pool 中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到 Buffer Pool 中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer 的意义是什么呢?</p><p>先来看一幅图，这个是二级索引的结构图：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051640799.png" alt=""></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘 IO。有了 ChangeBuffer 之后，我们可以在缓冲池中进行合并处理，减少磁盘 IO。</p><ol><li>Adaptive Hash Index</li></ol><p>自适应 hash 索引，用于优化对 Buffer Pool 数据的查询。MySQL 的 innoDB 引擎中虽然没有直接支持 hash 索引，但是给我们提供了一个功能就是这个自适应 hash 索引。因为前面我们讲到过，hash 索引在进行等值匹配时，一般性能是要高于 B+树的，因为 hash 索引一般只需要一次 IO 即可，而 B+树，可能需要几次匹配，所以 hash 索引的效率要高，但是 hash 索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB 存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下 hash 索引可以提升速度，则建立 hash 索引，称之为自适应 hash 索引。</p><p><strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</strong></p><p>参数： adaptive_hash_index</p><ol><li>Log Buffer</li></ol><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的 log 日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p><p>参数:</p><p>innodb_log_buffer_size：缓冲区大小</p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><ul><li><p>1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p></li><li><p>0: 每秒将日志写入并刷新到磁盘一次。</p></li><li>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</li></ul><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><ol><li>System Tablespace</li></ol><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在 MySQL5.x 版本中还包含 InnoDB 数据字典、undolog 等)</p><p>参数：innodb_data_file_path</p><p>系统表空间，默认的文件名叫 ibdata1。</p><ol><li>File-Per-Table Tablespaces</li></ol><p>如果开启了 innodb_file_per_table 开关 ，则每个表的文件表空间包含单个 InnoDB 表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p><p>开关参数：innodb_file_per_table ，该参数默认开启。</p><ol><li>General Tablespaces</li></ol><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p><p>创建表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE ts_name <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;file_name&#x27;</span> ENGINE <span class="operator">=</span> engine_name;</span><br></pre></td></tr></table></figure><p>创建表时指定表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> xxx ... TABLESPACE ts_name;</span><br></pre></td></tr></table></figure><ol><li>Undo Tablespaces</li></ol><p>撤销表空间，MySQL 实例在初始化时会自动创建两个默认的 undo 表空间（初始大小 16M），用于存储</p><p>undo log 日志。</p><ol><li>Temporary Tablespaces</li></ol><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><ol><li>Doublewrite Buffer Files</li></ol><p>双写缓冲区，innoDB 引擎将数据页从 Buffer Pool 刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051653093.png" style="zoom:50%"></p><ol><li>Redo Log</li></ol><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo logbuffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051646456.png" style="zoom:50%"></p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>在 InnoDB 的后台线程中，分为 4 类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。</p><p>1). Master Thread</p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo 页的回收 。</p><p>2). IO Thread</p><p>在 InnoDB 存储引擎中大量使用了 AIO 来处理 IO 请求, 这样可以极大地提高数据库的性能，而 IO Thread 主要负责这些 IO 请求的回调。</p><div class="table-container"><table><thead><tr><th style="text-align:center">线程类型</th><th style="text-align:center">默认个数</th><th style="text-align:center">职责</th></tr></thead><tbody><tr><td style="text-align:center">Read thread</td><td style="text-align:center">4</td><td style="text-align:center">负责读操作</td></tr><tr><td style="text-align:center">Write thread</td><td style="text-align:center">4</td><td style="text-align:center">负责写操作</td></tr><tr><td style="text-align:center">Log thread</td><td style="text-align:center">1</td><td style="text-align:center">负责将日志缓冲区刷新到磁盘</td></tr><tr><td style="text-align:center">Insert buffer thread</td><td style="text-align:center">1</td><td style="text-align:center">负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table></div><p>我们可以通过以下的这条指令，查看到 InnoDB 的状态信息，其中就包含 IO Thread 信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status \G;</span><br></pre></td></tr></table></figure><ol><li>Purge Thread</li></ol><p>主要用于回收事务已经提交了的 undo log，在事务提交之后，undo log 可能不用了，就用它来回收。</p><ol><li>Page Cleaner Thread</li></ol><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h3><ol><li>事务</li></ol><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><ol><li>特性</li></ol><ul><li><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p></li><li><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p></li><li><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></li></ul><p>那实际上，我们研究事务的原理，就是研究 MySQL 的 InnoDB 引擎是如何保证事务的这四大特性的。</p><p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由 InnoDB 中的两份日志来保证的，一份是 redo log 日志，一份是 undo log 日志。 而持久性是通过数据库的锁，加上 MVCC 来保证的</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051722573.png" alt=""></p><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>在 InnoDB 引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB 引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306051746193.png" alt=""></p><p>有了 redolog 之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在 redolog buffer 中。在事务提交时，会将 redo log buffer 中的数据刷新到 redo log 磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于 redo log 进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时 redolog 就没有作用了，就可以删除了，所以存在的两个 redolog 文件是循环写的。</p><blockquote><p>那为什么每一次提交事务，要刷新 redo log 到磁盘中呢，而不是直接将 buffer pool 中的脏页刷新到磁盘呢 ?</p><p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而 redo log 在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p></blockquote><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时，undolog 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这些日志可能还用于 MVCC。</p><p>Undo log 存储：undo log 采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含 1024 个 undo log segment。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>当前读</li></ol><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p><ol><li>快照读</li></ol><p>简单的 select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li><p>Read Committed：每次 select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个 select 语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><ol><li>MVCC</li></ol><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 日志、readView。</p><h3 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h3><p>在创建表结构时，InnoDB 还会自动的给我们添加三个隐藏字段及其含义分别是：</p><div class="table-container"><table><thead><tr><th style="text-align:center">隐式字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">DB_TRX_ID</td><td style="text-align:center">最近修改事务 ID，记录插入这条记录或最后一次修改该记录的事务 ID。</td></tr><tr><td style="text-align:center">DB_ROLL_PTR</td><td style="text-align:center">回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本。</td></tr><tr><td style="text-align:center">DB_ROW_ID</td><td style="text-align:center">隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table></div><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段 DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p><p><strong>查看有主键的表 stu:</strong></p><p>进入服务器中的 /var/lib/mysql/itcast/ , 查看 stu 的表结构信息, 通过如下指令:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi stu.ibd</span><br></pre></td></tr></table></figure><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有 DB_ROW_ID 隐藏字段。</p><p><strong>查看没有主键的表 employee:</strong></p><p>此时，我们再通过以下指令来查看表结构及其其中的字段信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi employee.ibd</span><br></pre></td></tr></table></figure><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为 employee 表是没有指定主键的。</p><h3 id="uodolog"><a href="#uodolog" class="headerlink" title="uodolog"></a>uodolog</h3><h4 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h4><p>回滚日志，在 insert、update、delete 的时候产生的便于数据回滚的日志。当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可被立即删除。 而 update、delete 的时候，产生的 undo log 日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>原始表数据：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306081352640.png" style="zoom:50%"></p><p>DB_TRX_ID : 代表最近修改事务 ID，记录插入这条记录或最后一次修改该记录的事务 ID，是自增的。</p><p>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为 null。</p><p>当有四个事务同时访问时</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306081401234.png" style="zoom:50%"></p><p>第一步：</p><p>当事务 2 执行第一条修改语句时，会记录 undo log 日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务 ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306081400218.png" alt=""></p><p>第二步：</p><p>当事务 3 执行第一条修改语句时，也会记录 undo log 日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务 ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306081402980.png" alt=""></p><p>第三步：</p><p>当事务 4 执行第一条修改语句时，也会记录 undo log 日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务 ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306081403550.png" alt=""></p><blockquote><p>最终发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的 undolog 生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></blockquote><h3 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h3><p>ReadView（读视图）是 快照读 SQL 执行时 MVCC 提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>ReadView 中包含了四个核心字段：</p><div class="table-container"><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">m_ids</td><td style="text-align:center">当前活跃的事务 ID 集合</td></tr><tr><td style="text-align:center">min_trx_id</td><td style="text-align:center">最小活跃事务 ID</td></tr><tr><td style="text-align:center">max_trx_id</td><td style="text-align:center">预分配事务 ID，当前最大事务 ID+1（因为事务 ID 是自增的）</td></tr><tr><td style="text-align:center">creator_trx_id</td><td style="text-align:center">ReadView 创建者的事务 ID</td></tr></tbody></table></div><p>而在 readview 中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前 undolog 版本链对应事务 ID。</p><div class="table-container"><table><thead><tr><th style="text-align:center">条件</th><th style="text-align:center">是否可以访问</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">trx_id == creator_trx_id</td><td style="text-align:center">可以访问该版本</td><td style="text-align:center">成立，说明数据是当前这个事务更改的。</td></tr><tr><td style="text-align:center">trx_id &lt; min_trx_id</td><td style="text-align:center">可以访问该版本</td><td style="text-align:center">成立，说明数据已经提交了。</td></tr><tr><td style="text-align:center">trx_id &gt; max_trx_id</td><td style="text-align:center">不可以访问该版本</td><td style="text-align:center">成立，说明该事务是在 ReadView 生成后才开启。</td></tr><tr><td style="text-align:center">min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td style="text-align:center">如果 trx_id 不在 m_ids 中，是可以访问该版本的</td><td style="text-align:center">成立，说明数据已经提交。</td></tr></tbody></table></div><p>不同的隔离级别，生成 ReadView 的时机不同：</p><ul><li><p>READ COMMITTED ：在事务中每一次执行快照读时生成 ReadView。</p></li><li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成 ReadView，后续复用该 ReadView。</p></li></ul><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="READ-COMMITTED-隔离级别"><a href="#READ-COMMITTED-隔离级别" class="headerlink" title="READ COMMITTED 隔离级别"></a>READ COMMITTED 隔离级别</h4><p>RC 隔离级别下，在事务中每一次执行快照读时生成 ReadView。</p><p>在事务 5 中，查询了两次 id 为 30 的记录，由于隔离级别为 Read Committed，所以每一次进行快照读都会生成一个 ReadView，那么两次生成的 ReadView 如下。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306081437185.png" alt=""></p><p>那么这两次快照读在获取数据时，就需要根据所生成的 ReadView 以及 ReadView 的版本链访问规则，到 undolog 版本链中匹配数据，最终决定此次快照读返回的数据。</p><h4 id="READ-COMMITTED-隔离级别-1"><a href="#READ-COMMITTED-隔离级别-1" class="headerlink" title="READ COMMITTED 隔离级别"></a>READ COMMITTED 隔离级别</h4><p>RR 隔离级别下，仅在事务中第一次执行快照读时生成 ReadView，后续复用该 ReadView。 而 RR 是可重复读，在一个事务中，执行两次相同的 select 语句，查询到的结果是一样的。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306081439507.png" alt=""></p><p>在 RR 隔离级别下，只是在事务中第一次快照读时生成 ReadView，后续都是复用该 ReadView，那么既然 ReadView 都一样， ReadView 的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p><p>所以呢，MVCC 的实现原理就是通过 InnoDB 表的隐藏字段、UndoLog 版本链、ReadView 来实现的。而 MVCC + 锁，则实现了事务的隔离性。 而一致性则是由 redolog 与 undolog 保证。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306081441891.png" alt=""></p><h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p><p>MySQL 支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306121518963.png" style="zoom:50%"></p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li><p>主库出现问题，可以快速切换到从库提供服务。</p></li><li><p>实现读写分离，降低主库的访问压力。</p></li><li><p>可以在从库中执行备份，以避免备份期间影响主库服务。</p></li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>MySQL 主从复制的核心就是 二进制日志，具体的过程如下：</p><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306121520647.png" style="zoom:50%"></p><p>复制分成三步：</p><ol><li><p>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p></li><li><p>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p></li><li><p>slave 重做中继日志中的事件，将改变反映它自己的数据。</p></li></ol><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>准备好两台服务器之后，在上述的两台服务器中分别安装好 MySQL，并完成基础的初始化准备(安装、密码配置等操作)工作。 其中：</p><ul><li><p>192.168.200.200 作为主服务器 master</p></li><li><p>192.168.200.201 作为从服务器 slave</p></li></ul><h3 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h3><ol><li>修改配置文件 /etc/my.cnf</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：<span class="number">1</span> – <span class="number">232</span><span class="number">-1</span>，默认为<span class="number">1</span></span><br><span class="line">server<span class="operator">-</span>id<span class="operator">=</span><span class="number">1</span></span><br><span class="line">#是否只读,<span class="number">1</span> 代表只读, <span class="number">0</span> 代表读写</span><br><span class="line">read<span class="operator">-</span><span class="keyword">only</span><span class="operator">=</span><span class="number">0</span></span><br><span class="line">#忽略的数据, 指不需要同步的数据库</span><br><span class="line">#binlog<span class="operator">-</span>ignore<span class="operator">-</span>db<span class="operator">=</span>mysql</span><br><span class="line">#指定同步的数据库</span><br><span class="line">#binlog<span class="operator">-</span>do<span class="operator">-</span>db<span class="operator">=</span>db01</span><br></pre></td></tr></table></figure><ol><li>重启 MySQL 服务器</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systenctl restart mysqld</span><br></pre></td></tr></table></figure><ol><li>登录 mysql，创建远程连接的账号，并授予主从复制权限</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;Root@123456&#x27;</span> ;</span><br><span class="line">#为 <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> 用户分配主从复制权限</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>通过指令，查看二进制日志坐标</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> master status ; <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306121546237.png" alt=""></p><p>字段含义说明：</p><ul><li><p>file : 从哪个日志文件开始推送日志文件</p></li><li><p>position ： 从哪个位置开始推送日志</p></li><li><p>binlog_ignore_db : 指定不需要同步的数据库</p></li></ul><h3 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h3><ol><li>修改配置文件 /etc/my.cnf</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：<span class="number">1</span> – <span class="number">2</span><span class="operator">^</span><span class="number">32</span><span class="number">-1</span>，和主库不一样即可</span><br><span class="line">server<span class="operator">-</span>id<span class="operator">=</span><span class="number">2</span></span><br><span class="line">#是否只读,<span class="number">1</span> 代表只读, <span class="number">0</span> 代表读写</span><br><span class="line">read<span class="operator">-</span><span class="keyword">only</span><span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><ol><li>重新启动 MySQL 服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld 1</span><br></pre></td></tr></table></figure><ol><li>登录 mysql，设置主库配置</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">8.0</span><span class="number">.23</span>中的语法</span><br><span class="line">CHANGE REPLICATION SOURCE <span class="keyword">TO</span> SOURCE_HOST<span class="operator">=</span><span class="string">&#x27;192.168.200.200&#x27;</span>, SOURCE_USER<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, SOURCE_PASSWORD<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>, SOURCE_LOG_FILE<span class="operator">=</span><span class="string">&#x27;binlog.000004&#x27;</span>, SOURCE_LOG_POS<span class="operator">=</span><span class="number">663</span>;</span><br><span class="line"></span><br><span class="line"># mysql是 <span class="number">8.0</span><span class="number">.23</span> 之前的版本</span><br><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_HOST<span class="operator">=</span><span class="string">&#x27;192.168.200.200&#x27;</span>, MASTER_USER<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>, MASTER_LOG_FILE<span class="operator">=</span><span class="string">&#x27;binlog.000004&#x27;</span>, MASTER_LOG_POS<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">参数名</th><th style="text-align:center">含义</th><th style="text-align:center">8.0.23 之前</th></tr></thead><tbody><tr><td style="text-align:center">SOURCE_HOST</td><td style="text-align:center">主库 IP 地址</td><td style="text-align:center">MASTER_HOST</td></tr><tr><td style="text-align:center">SOURCE_USER</td><td style="text-align:center">连接主库的用户名</td><td style="text-align:center">MASTER_USER</td></tr><tr><td style="text-align:center">SOURCE_PASSWORD</td><td style="text-align:center">连接主库的密码</td><td style="text-align:center">MASTER_PASSWORD</td></tr><tr><td style="text-align:center">SOURCE_LOG_FILE</td><td style="text-align:center">binlog 日志文件名</td><td style="text-align:center">MASTER_LOG_FILE</td></tr><tr><td style="text-align:center">SOURCE_LOG_POS</td><td style="text-align:center">binlog 日志文件位置</td><td style="text-align:center">MASTER_LOG_POS</td></tr></tbody></table></div><ol><li>开启同步操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> replica ; #<span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">start</span> slave ; #<span class="number">8.0</span><span class="number">.22</span>之前</span><br></pre></td></tr></table></figure><ol><li>查看主从同步状态</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status ; #<span class="number">8.0</span><span class="number">.22</span>之后</span><br><span class="line"><span class="keyword">show</span> slave status ; #<span class="number">8.0</span><span class="number">.22</span>之前</span><br></pre></td></tr></table></figure><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306121546305.png" style="zoom:50%"></p><h2 id="主从同步延迟"><a href="#主从同步延迟" class="headerlink" title="主从同步延迟"></a>主从同步延迟</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器里面读取 binlog 的线程仅有一个，当某个 SQL 在从服务器上执行的时间稍长 或者由于某个 SQL 要进行锁表就会导致：主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是<strong>主从延迟</strong>。</p><h3 id="主从同步延迟的解决办法"><a href="#主从同步延迟的解决办法" class="headerlink" title="主从同步延迟的解决办法"></a>主从同步延迟的解决办法</h3><ol><li>写操作后的读操作指定<strong>发给数据库主服务器</strong></li></ol><p>比如我们刚生成 100 个订单【从服务器复制需要一定时间】，后续去显示已生成订单的时候，这个读操作也发给主服务器。</p><blockquote><p>这种方式和业务强耦合，对业务的侵入和影响较大，不利于扩展和维护</p></blockquote><ol><li>读从机失败后再读一次主机</li></ol><p>这就是通常所说的 “二次读取” ，二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。</p><ol><li><strong>关键业务读写</strong>操作全部指向主机，<strong>非关键业务</strong>采用读写分离</li></ol><p>像这种刚支付完，要看到自己支付的订单，这种属于关键业务，不容许太多读写不一致的情况，所以这些关键事务可以都指向主服务器，而其他比如点赞数量，非关键的业务就还是去读写分离。</p><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存</p><p>储，存在以下性能瓶颈：</p><ol><li><p>IO 瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘 IO，效率较低。 请求数据太多，带宽不够，网络 IO 瓶颈。</p></li><li><p>CPU 瓶颈：排序、分组、连接查询、聚合统计等 SQL 会耗费大量的 CPU 资源，请求数太多，CPU 出现瓶颈。</p></li></ol><p>为了解决上述问题，我们需要对数据库进行分库分表处理。</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306121555068.png" style="zoom:50%"></p><p>分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。</p><h2 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h2><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。而拆分的粒度，一般又分为分库和分表，所以组成的拆分策略最终如下：</p><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306141134844.png" style="zoom:33%"></p><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><ol><li>垂直分库</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306141155956.png" style="zoom:33%"></p><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ul><li><p>每个库的表结构都不一样。</p></li><li><p>每个库的数据也不一样。</p></li><li><p>所有库的并集是全量数据。</p></li></ul><ol><li>垂直分表</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306141156205.png" style="zoom:33%"></p><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点：</p><ul><li><p>每个表的结构都不一样。</p></li><li><p>每个表的数据也不一样，一般通过一列（主键/外键）关联。</p></li><li><p>所有表的并集是全量数据。</p></li></ul><h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><ol><li>水平分库</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306141140339.png" style="zoom:33%"></p><p>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。</p><p>特点：</p><ul><li><p>每个库的表结构都一样。</p></li><li><p>每个库的数据都不一样。</p></li><li><p>所有库的并集是全量数据。</p></li></ul><ol><li>水平分表</li></ol><p><img src="https://blogcdn.dyfnb.xyz/img/post/202306141142585.png" style="zoom:33%"></p><p>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。</p><p>特点：</p><ul><li><p>每个表的表结构都一样。</p></li><li><p>每个表的数据都不一样。</p></li><li><p>所有表的并集是全量数据。</p></li></ul><blockquote><p>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分库，还是分表，都需要根据具体的业务需求具体分析。</p></blockquote><h2 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h2><ul><li><p>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言，性能较高。</p></li><li><p>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</p></li></ul><h2 id="Mcat"><a href="#Mcat" class="headerlink" title="Mcat"></a>Mcat</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>官网：<a target="_blank" rel="noopener" href="http://mycatone.top/">http://mycatone.top/</a></p><p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat，对于开发人员来说根本感觉不到mycat的存在。</p><p>开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。 具体的分库分表的策略，只需要在MyCat中配置即可。</p><p>优势：</p><ul><li>性能可靠稳定</li><li>强大的技术团队</li><li>体系完善</li><li>社区活跃</li></ul><h3 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载&amp;安装"></a>下载&amp;安装</h3><p>下载地址：<a target="_blank" rel="noopener" href="http://dl.mycat.org.cn/">http://dl.mycat.org.cn/</a></p><p>具体的安装步骤可以查看<a target="_blank" rel="noopener" href="https://github.com/MyCATApache/Mycat-Server/wiki/1.0-Mycat%E7%AE%80%E4%BB%8B">MyCat官方文档</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://blog.dyfnb.xyz">忆语</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.dyfnb.xyz/posts/c24675b4.html">https://blog.dyfnb.xyz/posts/c24675b4.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.dyfnb.xyz" target="_blank">忆语</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a><a class="post-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div><div class="post_share"><div class="social-share" data-image="https://blogcdn.dyfnb.xyz/img/post/202306141153062.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload='this.media="all"'><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://blogcdn.dyfnb.xyz/img/common/wechat.png" target="_blank"><img class="post-qr-code-img" src="https://blogcdn.dyfnb.xyz/img/common/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://blogcdn.dyfnb.xyz/img/common/ali.png" target="_blank"><img class="post-qr-code-img" src="https://blogcdn.dyfnb.xyz/img/common/ali.png" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/9a342e3a.html"><img class="next-cover" src="https://blogcdn.dyfnb.xyz/img/post/" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot内置工具类</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blogcdn.dyfnb.xyz/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">忆语</div><div class="author-info__description">面朝大海 春暖花开</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="https://blog.dyfnb.xyz/"><i></i><span>摆烂</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://gitee.com/xuexidong" target="_blank" title="Gitee"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitee"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=769632145@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-mail"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/430314138" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili1"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=769632145&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MYSQL-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">MYSQL 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">SQL 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DDL"><span class="toc-number">1.2.</span> <span class="toc-text">DDL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据库操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">表操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-amp-%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">查询&amp;创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DML"><span class="toc-number">1.3.</span> <span class="toc-text">DML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">添加数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">修改数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">删除数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DQL"><span class="toc-number">1.4.</span> <span class="toc-text">DQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.2.</span> <span class="toc-text">基础查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">条件查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">聚合函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.4.</span> <span class="toc-text">分组查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.5.</span> <span class="toc-text">排序查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.6.</span> <span class="toc-text">分页查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DCL"><span class="toc-number">1.5.</span> <span class="toc-text">DCL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%94%A8%E6%88%B7"><span class="toc-number">1.5.1.</span> <span class="toc-text">管理用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">权限控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">字符串函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">数值函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">日期函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">流程函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.2.</span> <span class="toc-text">外键约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-%E6%9B%B4%E6%96%B0%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.3.</span> <span class="toc-text">删除&#x2F;更新行为</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.</span> <span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">多表关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="toc-number">4.1.1.</span> <span class="toc-text">一对多</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-number">4.1.2.</span> <span class="toc-text">多对多</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-number">4.1.3.</span> <span class="toc-text">一对一</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%A6%82%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">多表查询概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.1.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.3.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.4.</span> <span class="toc-text">外连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.5.</span> <span class="toc-text">自连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.5.1.</span> <span class="toc-text">自连接查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.5.2.</span> <span class="toc-text">联合查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.6.</span> <span class="toc-text">子查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.6.2.</span> <span class="toc-text">标量子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.6.3.</span> <span class="toc-text">列子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.6.4.</span> <span class="toc-text">行子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.6.5.</span> <span class="toc-text">表子查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">5.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.2.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">5.2.2.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree"><span class="toc-number">5.2.3.</span> <span class="toc-text">B-Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree-1"><span class="toc-number">5.2.4.</span> <span class="toc-text">B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-%E7%B4%A2%E5%BC%95"><span class="toc-number">5.2.5.</span> <span class="toc-text">Hash 索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">索引分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-amp-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">聚集索引&amp;二级索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">索引语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">5.5.</span> <span class="toc-text">SQL 性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A2%91%E7%8E%87"><span class="toc-number">5.5.1.</span> <span class="toc-text">SQL 的执行频率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">5.5.2.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#profile-%E8%AF%A6%E6%83%85"><span class="toc-number">5.5.3.</span> <span class="toc-text">profile 详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explain"><span class="toc-number">5.5.4.</span> <span class="toc-text">explain</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-number">5.6.</span> <span class="toc-text">索引使用规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">5.6.1.</span> <span class="toc-text">最左前缀法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.6.2.</span> <span class="toc-text">范围查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-number">5.6.3.</span> <span class="toc-text">索引失效情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%90%E7%AE%97"><span class="toc-number">5.6.3.1.</span> <span class="toc-text">索引列运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E5%8A%A0%E5%BC%95%E5%8F%B7"><span class="toc-number">5.6.3.2.</span> <span class="toc-text">字符串不加引号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.6.3.3.</span> <span class="toc-text">模糊查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#or-%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.6.3.4.</span> <span class="toc-text">or 连接条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%BD%B1%E5%93%8D"><span class="toc-number">5.6.3.5.</span> <span class="toc-text">数据分布影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%8F%90%E7%A4%BA"><span class="toc-number">5.6.4.</span> <span class="toc-text">SQL 提示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.5.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.6.</span> <span class="toc-text">前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">5.6.7.</span> <span class="toc-text">单列索引与联合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">5.7.</span> <span class="toc-text">索引设计原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL-%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">SQL 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">6.1.</span> <span class="toc-text">插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#insert"><span class="toc-number">6.1.1.</span> <span class="toc-text">insert</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">6.1.2.</span> <span class="toc-text">大批量插入数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">主键优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.1.</span> <span class="toc-text">数据组织方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%88%86%E8%A3%82"><span class="toc-number">6.2.2.</span> <span class="toc-text">页分裂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%90%88%E5%B9%B6"><span class="toc-number">6.2.3.</span> <span class="toc-text">页合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-1"><span class="toc-number">6.2.4.</span> <span class="toc-text">索引设计原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#order-by-%E4%BC%98%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">order by 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#group-by-%E4%BC%98%E5%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text">group by 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#limit-%E4%BC%98%E5%8C%96"><span class="toc-number">6.5.</span> <span class="toc-text">limit 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#count-%E4%BC%98%E5%8C%96"><span class="toc-number">6.6.</span> <span class="toc-text">count 优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">6.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count-%E7%94%A8%E6%B3%95"><span class="toc-number">6.6.2.</span> <span class="toc-text">count 用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#update-%E4%BC%98%E5%8C%96"><span class="toc-number">6.7.</span> <span class="toc-text">update 优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">7.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">7.2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">7.2.1.</span> <span class="toc-text">新建视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE"><span class="toc-number">7.2.2.</span> <span class="toc-text">查询视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A7%86%E5%9B%BE"><span class="toc-number">7.2.3.</span> <span class="toc-text">修改视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">7.2.4.</span> <span class="toc-text">删除视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.2.5.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%80%89%E9%A1%B9"><span class="toc-number">7.3.</span> <span class="toc-text">检查选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CASCADED-%E7%BA%A7%E8%81%94"><span class="toc-number">7.3.1.</span> <span class="toc-text">CASCADED 级联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LOCAL-%E6%9C%AC%E5%9C%B0"><span class="toc-number">7.3.2.</span> <span class="toc-text">LOCAL 本地</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-number">7.4.</span> <span class="toc-text">视图的更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">7.5.</span> <span class="toc-text">视图的作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">8.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">8.2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">创建存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.2.</span> <span class="toc-text">调用存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.3.</span> <span class="toc-text">更新存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.4.</span> <span class="toc-text">删除存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">8.2.5.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.1.</span> <span class="toc-text">系统变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.2.</span> <span class="toc-text">用户定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.3.</span> <span class="toc-text">局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if"><span class="toc-number">8.4.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">8.5.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#case"><span class="toc-number">8.6.</span> <span class="toc-text">case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while"><span class="toc-number">8.7.</span> <span class="toc-text">while</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#repeat"><span class="toc-number">8.8.</span> <span class="toc-text">repeat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loop"><span class="toc-number">8.9.</span> <span class="toc-text">loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">8.10.</span> <span class="toc-text">游标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.11.</span> <span class="toc-text">条件处理程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">存储函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">10.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-4"><span class="toc-number">10.2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">10.2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B"><span class="toc-number">10.2.2.</span> <span class="toc-text">查看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-number">10.2.3.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">10.2.4.</span> <span class="toc-text">案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">11.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">11.2.</span> <span class="toc-text">全局锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">11.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-5"><span class="toc-number">11.2.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">11.2.3.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">11.3.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">11.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">11.3.2.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-number">11.3.3.</span> <span class="toc-text">元数据锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">11.3.4.</span> <span class="toc-text">意向锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">11.4.</span> <span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">11.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-number">11.4.2.</span> <span class="toc-text">行锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81-amp-%E4%B8%B4%E9%94%AE%E9%94%81"><span class="toc-number">11.4.3.</span> <span class="toc-text">间隙锁&amp;临键锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB-%E5%BC%95%E6%93%8E"><span class="toc-number">12.</span> <span class="toc-text">InnoDB 引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">12.1.</span> <span class="toc-text">逻辑存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">12.2.</span> <span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">12.2.1.</span> <span class="toc-text">内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-number">12.2.2.</span> <span class="toc-text">磁盘结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.2.3.</span> <span class="toc-text">后台线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">12.3.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">12.3.1.</span> <span class="toc-text">事务基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-number">12.3.2.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-number">12.3.3.</span> <span class="toc-text">undo log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-number">12.4.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">12.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">12.4.2.</span> <span class="toc-text">隐式字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uodolog"><span class="toc-number">12.4.3.</span> <span class="toc-text">uodolog</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">12.4.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E9%93%BE"><span class="toc-number">12.4.3.2.</span> <span class="toc-text">版本链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#readview"><span class="toc-number">12.4.4.</span> <span class="toc-text">readview</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">12.4.5.</span> <span class="toc-text">原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#READ-COMMITTED-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">12.4.5.1.</span> <span class="toc-text">READ COMMITTED 隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#READ-COMMITTED-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB-1"><span class="toc-number">12.4.5.2.</span> <span class="toc-text">READ COMMITTED 隔离级别</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">13.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">13.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">13.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA"><span class="toc-number">13.3.</span> <span class="toc-text">搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%BA%93%E9%85%8D%E7%BD%AE"><span class="toc-number">13.3.1.</span> <span class="toc-text">主库配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%BA%93%E9%85%8D%E7%BD%AE"><span class="toc-number">13.3.2.</span> <span class="toc-text">从库配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F"><span class="toc-number">13.4.</span> <span class="toc-text">主从同步延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">13.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">13.4.2.</span> <span class="toc-text">主从同步延迟的解决办法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">14.</span> <span class="toc-text">分库分表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">14.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5"><span class="toc-number">14.2.</span> <span class="toc-text">拆分策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E6%8B%86%E5%88%86"><span class="toc-number">14.2.1.</span> <span class="toc-text">垂直拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E6%8B%86%E5%88%86"><span class="toc-number">14.2.2.</span> <span class="toc-text">水平拆分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">14.3.</span> <span class="toc-text">实现技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mcat"><span class="toc-number">14.4.</span> <span class="toc-text">Mcat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">14.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD-amp-%E5%AE%89%E8%A3%85"><span class="toc-number">14.4.2.</span> <span class="toc-text">下载&amp;安装</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c24675b4.html" title="MySQL"><img src="https://blogcdn.dyfnb.xyz/img/post/202306141153062.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="MySQL"></a><div class="content"><a class="title" href="/posts/c24675b4.html" title="MySQL">MySQL</a><time datetime="2023-05-13T07:41:48.000Z" title="发表于 2023-05-13 15:41:48">2023-05-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9a342e3a.html" title="SpringBoot内置工具类"><img src="https://blogcdn.dyfnb.xyz/img/post/" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SpringBoot内置工具类"></a><div class="content"><a class="title" href="/posts/9a342e3a.html" title="SpringBoot内置工具类">SpringBoot内置工具类</a><time datetime="2023-05-06T09:57:55.000Z" title="发表于 2023-05-06 17:57:55">2023-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d0edc1ed.html" title="Linux常用命令"><img src="https://blogcdn.dyfnb.xyz/img/post/20230308164737.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Linux常用命令"></a><div class="content"><a class="title" href="/posts/d0edc1ed.html" title="Linux常用命令">Linux常用命令</a><time datetime="2023-03-08T08:25:23.000Z" title="发表于 2023-03-08 16:25:23">2023-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/761fcbb2.html" title="JAVA面试题"><img src="https://blogcdn.dyfnb.xyz/img/post/20230227152445.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="JAVA面试题"></a><div class="content"><a class="title" href="/posts/761fcbb2.html" title="JAVA面试题">JAVA面试题</a><time datetime="2023-02-27T07:19:33.000Z" title="发表于 2023-02-27 15:19:33">2023-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 忆语</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.dyfnb.xyz/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.dyfnb.xyz/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="/js/title.js"></script><div class="aplayer no-destroy" data-id="3778678" data-server="netease" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true"></div><script async src="/js/grayscale.js"></script><script async src="//at.alicdn.com/t/c/font_3798423_e08oylinl5t.js"></script><script src="/js/sun_moon.js" async></script><script defer src="/js/console.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://blog.dyfnb.xyz/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 前端学习 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://blog.dyfnb.xyz/categories/面试/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👨‍🎓 面试汇总 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://blog.dyfnb.xyz/categories/笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 学习笔记 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://blog.dyfnb.xyz/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var e=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),e&&e.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="/posts/".split(","),cpage=location.pathname,epage="all",qweather_key="9ca7bf9a1f294eb9a65b6198a8b6ce1b",gaud_map_key="da129e0f17def92024f0856af7ae1241",baidu_ak_key="undefined",flag=0,clock_rectangle="114.298572,30.584355",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_clock_anzhiyu_injector_config():epage===cpage&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.8/lib/clock.min.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="/js/ali_font.js"></script><script data-pjax>function butterfly_footer_beautify_injector_config(){var t=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),t.insertAdjacentHTML("beforeend",'<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_footer_beautify_injector_config():epage===cpage&&butterfly_footer_beautify_injector_config()</script><script async src="/js/runtime/runtime.min.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/"})</script></body></html>